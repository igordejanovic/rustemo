/// Generated by rustemo. Do not edit manually!
use std::fmt::Debug;
use std::hash::Hash;
use rustemo::{
    Result, Input as InputT, Lexer, Token, TokenRecognizer as TokenRecognizerT, Parser,
    ParserDefinition, State as StateT, Builder,
};
use rustemo::regex::Regex;
use rustemo::once_cell::sync::Lazy;
use rustemo::StringLexer;
use rustemo::LRBuilder;
use super::rustemo_actions;
use rustemo::{LRParser, LRContext};
use rustemo::Action::{self, Shift, Reduce, Accept};
#[allow(unused_imports)]
use rustemo::debug::{log, logn};
#[allow(unused_imports)]
#[cfg(debug_assertions)]
use rustemo::yansi::Paint;
pub type Input = str;
const STATE_COUNT: usize = 145usize;
const MAX_RECOGNIZERS: usize = 15usize;
#[allow(dead_code)]
const TERMINAL_COUNT: usize = 44usize;
#[allow(clippy::upper_case_acronyms)]
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TokenKind {
    #[default]
    STOP,
    Terminals,
    Import,
    As,
    Colon,
    SemiColon,
    Comma,
    OBrace,
    CBrace,
    OBracket,
    CBracket,
    OSBracket,
    CSBracket,
    Choice,
    ZeroOrMore,
    ZeroOrMoreGreedy,
    OneOrMore,
    OneOrMoreGreedy,
    Optional,
    OptionalGreedy,
    Equals,
    QEquals,
    Left,
    Right,
    Reduce,
    Shift,
    Dynamic,
    NOPS,
    NOPSE,
    Prefer,
    Finish,
    NoFinish,
    OComment,
    CComment,
    Name,
    RegexTerm,
    IntConst,
    FloatConst,
    BoolConst,
    StrConst,
    Annotation,
    WS,
    CommentLine,
    NotComment,
}
use TokenKind as TK;
impl From<TokenKind> for usize {
    fn from(t: TokenKind) -> Self {
        t as usize
    }
}
#[allow(clippy::enum_variant_names)]
#[derive(Clone, Copy, PartialEq)]
pub enum ProdKind {
    FileP1,
    GrammarRule1P1,
    GrammarRule1P2,
    FileP2,
    ImportStm1P1,
    ImportStm1P2,
    FileP3,
    TerminalRule1P1,
    TerminalRule1P2,
    FileP4,
    FileP5,
    ImportStmP1,
    ImportStmP2,
    GrammarRuleP1,
    AnnotationOptP1,
    AnnotationOptP2,
    GrammarRuleP2,
    GrammarRuleRHSP1,
    GrammarRuleRHSP2,
    ProductionP1,
    Assignment1P1,
    Assignment1P2,
    ProductionP2,
    TerminalRuleP1,
    TerminalRuleP2,
    TerminalRuleP3,
    TerminalRuleP4,
    ProdMetaDataLeft,
    ProdMetaDataReduce,
    ProdMetaDataRight,
    ProdMetaDataShift,
    ProdMetaDataDynamic,
    ProdMetaDataNOPS,
    ProdMetaDataNOPSE,
    ProdMetaDataPriority,
    ProdMetaDataP9,
    ProdMetaDataP10,
    ProdMetaDatasP1,
    ProdMetaDatasP2,
    TermMetaDataPrefer,
    TermMetaDataFinish,
    TermMetaDataNoFinish,
    TermMetaDataLeft,
    TermMetaDataReduce,
    TermMetaDataRight,
    TermMetaDataShift,
    TermMetaDataDynamic,
    TermMetaDataPriority,
    TermMetaDataP10,
    TermMetaDatasP1,
    TermMetaDatasP2,
    UserMetaDataP1,
    ProdKindP1,
    ConstValP1,
    ConstValP2,
    ConstValP3,
    ConstValP4,
    AssignmentP1,
    AssignmentP2,
    AssignmentP3,
    PlainAssignmentP1,
    BoolAssignmentP1,
    ProductionGroupP1,
    GrammarSymbolRefP1,
    RepetitionOperatorOptP1,
    RepetitionOperatorOptP2,
    GrammarSymbolRefP2,
    RepetitionOperatorP1,
    RepetitionModifiersOptP1,
    RepetitionModifiersOptP2,
    RepetitionOperatorOpZeroOrMore,
    RepetitionOperatorOpZeroOrMoreGreedy,
    RepetitionOperatorOpOneOrMore,
    RepetitionOperatorOpOneOrMoreGreedy,
    RepetitionOperatorOpOptional,
    RepetitionOperatorOpOptionalGreedy,
    RepetitionModifiersP1,
    RepetitionModifier1P1,
    RepetitionModifier1P2,
    RepetitionModifierP1,
    GrammarSymbolP1,
    GrammarSymbolP2,
    RecognizerP1,
    RecognizerP2,
    LayoutP1,
    LayoutItem1P1,
    LayoutItem1P2,
    LayoutItem0P1,
    LayoutItem0P2,
    LayoutItemP1,
    LayoutItemP2,
    CommentP1,
    CommentP2,
    CorncsP1,
    Cornc1P1,
    Cornc1P2,
    Cornc0P1,
    Cornc0P2,
    CorncP1,
    CorncP2,
    CorncP3,
}
use ProdKind as PK;
impl std::fmt::Debug for ProdKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let name = match self {
            ProdKind::FileP1 => "File: GrammarRule1",
            ProdKind::GrammarRule1P1 => "GrammarRule1: GrammarRule1 GrammarRule",
            ProdKind::GrammarRule1P2 => "GrammarRule1: GrammarRule",
            ProdKind::FileP2 => "File: ImportStm1 GrammarRule1",
            ProdKind::ImportStm1P1 => "ImportStm1: ImportStm1 ImportStm",
            ProdKind::ImportStm1P2 => "ImportStm1: ImportStm",
            ProdKind::FileP3 => "File: GrammarRule1 Terminals TerminalRule1",
            ProdKind::TerminalRule1P1 => "TerminalRule1: TerminalRule1 TerminalRule",
            ProdKind::TerminalRule1P2 => "TerminalRule1: TerminalRule",
            ProdKind::FileP4 => "File: ImportStm1 GrammarRule1 Terminals TerminalRule1",
            ProdKind::FileP5 => "File: Terminals TerminalRule1",
            ProdKind::ImportStmP1 => "ImportStm: Import StrConst",
            ProdKind::ImportStmP2 => "ImportStm: Import StrConst As Name",
            ProdKind::GrammarRuleP1 => {
                "GrammarRule: AnnotationOpt Name Colon GrammarRuleRHS SemiColon"
            }
            ProdKind::AnnotationOptP1 => "AnnotationOpt: Annotation",
            ProdKind::AnnotationOptP2 => "AnnotationOpt: ",
            ProdKind::GrammarRuleP2 => {
                "GrammarRule: AnnotationOpt Name OBrace ProdMetaDatas CBrace Colon GrammarRuleRHS SemiColon"
            }
            ProdKind::GrammarRuleRHSP1 => {
                "GrammarRuleRHS: GrammarRuleRHS Choice Production"
            }
            ProdKind::GrammarRuleRHSP2 => "GrammarRuleRHS: Production",
            ProdKind::ProductionP1 => "Production: Assignment1",
            ProdKind::Assignment1P1 => "Assignment1: Assignment1 Assignment",
            ProdKind::Assignment1P2 => "Assignment1: Assignment",
            ProdKind::ProductionP2 => {
                "Production: Assignment1 OBrace ProdMetaDatas CBrace"
            }
            ProdKind::TerminalRuleP1 => {
                "TerminalRule: AnnotationOpt Name Colon Recognizer SemiColon"
            }
            ProdKind::TerminalRuleP2 => {
                "TerminalRule: AnnotationOpt Name Colon SemiColon"
            }
            ProdKind::TerminalRuleP3 => {
                "TerminalRule: AnnotationOpt Name Colon Recognizer OBrace TermMetaDatas CBrace SemiColon"
            }
            ProdKind::TerminalRuleP4 => {
                "TerminalRule: AnnotationOpt Name Colon OBrace TermMetaDatas CBrace SemiColon"
            }
            ProdKind::ProdMetaDataLeft => "ProdMetaData: Left",
            ProdKind::ProdMetaDataReduce => "ProdMetaData: Reduce",
            ProdKind::ProdMetaDataRight => "ProdMetaData: Right",
            ProdKind::ProdMetaDataShift => "ProdMetaData: Shift",
            ProdKind::ProdMetaDataDynamic => "ProdMetaData: Dynamic",
            ProdKind::ProdMetaDataNOPS => "ProdMetaData: NOPS",
            ProdKind::ProdMetaDataNOPSE => "ProdMetaData: NOPSE",
            ProdKind::ProdMetaDataPriority => "ProdMetaData: IntConst",
            ProdKind::ProdMetaDataP9 => "ProdMetaData: UserMetaData",
            ProdKind::ProdMetaDataP10 => "ProdMetaData: ProdKind",
            ProdKind::ProdMetaDatasP1 => {
                "ProdMetaDatas: ProdMetaDatas Comma ProdMetaData"
            }
            ProdKind::ProdMetaDatasP2 => "ProdMetaDatas: ProdMetaData",
            ProdKind::TermMetaDataPrefer => "TermMetaData: Prefer",
            ProdKind::TermMetaDataFinish => "TermMetaData: Finish",
            ProdKind::TermMetaDataNoFinish => "TermMetaData: NoFinish",
            ProdKind::TermMetaDataLeft => "TermMetaData: Left",
            ProdKind::TermMetaDataReduce => "TermMetaData: Reduce",
            ProdKind::TermMetaDataRight => "TermMetaData: Right",
            ProdKind::TermMetaDataShift => "TermMetaData: Shift",
            ProdKind::TermMetaDataDynamic => "TermMetaData: Dynamic",
            ProdKind::TermMetaDataPriority => "TermMetaData: IntConst",
            ProdKind::TermMetaDataP10 => "TermMetaData: UserMetaData",
            ProdKind::TermMetaDatasP1 => {
                "TermMetaDatas: TermMetaDatas Comma TermMetaData"
            }
            ProdKind::TermMetaDatasP2 => "TermMetaDatas: TermMetaData",
            ProdKind::UserMetaDataP1 => "UserMetaData: Name Colon ConstVal",
            ProdKind::ProdKindP1 => "ProdKind: Name",
            ProdKind::ConstValP1 => "ConstVal: IntConst",
            ProdKind::ConstValP2 => "ConstVal: FloatConst",
            ProdKind::ConstValP3 => "ConstVal: BoolConst",
            ProdKind::ConstValP4 => "ConstVal: StrConst",
            ProdKind::AssignmentP1 => "Assignment: PlainAssignment",
            ProdKind::AssignmentP2 => "Assignment: BoolAssignment",
            ProdKind::AssignmentP3 => "Assignment: GrammarSymbolRef",
            ProdKind::PlainAssignmentP1 => {
                "PlainAssignment: Name Equals GrammarSymbolRef"
            }
            ProdKind::BoolAssignmentP1 => "BoolAssignment: Name QEquals GrammarSymbolRef",
            ProdKind::ProductionGroupP1 => {
                "ProductionGroup: OBracket GrammarRuleRHS CBracket"
            }
            ProdKind::GrammarSymbolRefP1 => {
                "GrammarSymbolRef: GrammarSymbol RepetitionOperatorOpt"
            }
            ProdKind::RepetitionOperatorOptP1 => {
                "RepetitionOperatorOpt: RepetitionOperator"
            }
            ProdKind::RepetitionOperatorOptP2 => "RepetitionOperatorOpt: ",
            ProdKind::GrammarSymbolRefP2 => {
                "GrammarSymbolRef: ProductionGroup RepetitionOperatorOpt"
            }
            ProdKind::RepetitionOperatorP1 => {
                "RepetitionOperator: RepetitionOperatorOp RepetitionModifiersOpt"
            }
            ProdKind::RepetitionModifiersOptP1 => {
                "RepetitionModifiersOpt: RepetitionModifiers"
            }
            ProdKind::RepetitionModifiersOptP2 => "RepetitionModifiersOpt: ",
            ProdKind::RepetitionOperatorOpZeroOrMore => {
                "RepetitionOperatorOp: ZeroOrMore"
            }
            ProdKind::RepetitionOperatorOpZeroOrMoreGreedy => {
                "RepetitionOperatorOp: ZeroOrMoreGreedy"
            }
            ProdKind::RepetitionOperatorOpOneOrMore => "RepetitionOperatorOp: OneOrMore",
            ProdKind::RepetitionOperatorOpOneOrMoreGreedy => {
                "RepetitionOperatorOp: OneOrMoreGreedy"
            }
            ProdKind::RepetitionOperatorOpOptional => "RepetitionOperatorOp: Optional",
            ProdKind::RepetitionOperatorOpOptionalGreedy => {
                "RepetitionOperatorOp: OptionalGreedy"
            }
            ProdKind::RepetitionModifiersP1 => {
                "RepetitionModifiers: OSBracket RepetitionModifier1 CSBracket"
            }
            ProdKind::RepetitionModifier1P1 => {
                "RepetitionModifier1: RepetitionModifier1 Comma RepetitionModifier"
            }
            ProdKind::RepetitionModifier1P2 => "RepetitionModifier1: RepetitionModifier",
            ProdKind::RepetitionModifierP1 => "RepetitionModifier: Name",
            ProdKind::GrammarSymbolP1 => "GrammarSymbol: Name",
            ProdKind::GrammarSymbolP2 => "GrammarSymbol: StrConst",
            ProdKind::RecognizerP1 => "Recognizer: StrConst",
            ProdKind::RecognizerP2 => "Recognizer: RegexTerm",
            ProdKind::LayoutP1 => "Layout: LayoutItem0",
            ProdKind::LayoutItem1P1 => "LayoutItem1: LayoutItem1 LayoutItem",
            ProdKind::LayoutItem1P2 => "LayoutItem1: LayoutItem",
            ProdKind::LayoutItem0P1 => "LayoutItem0: LayoutItem1",
            ProdKind::LayoutItem0P2 => "LayoutItem0: ",
            ProdKind::LayoutItemP1 => "LayoutItem: WS",
            ProdKind::LayoutItemP2 => "LayoutItem: Comment",
            ProdKind::CommentP1 => "Comment: OComment Corncs CComment",
            ProdKind::CommentP2 => "Comment: CommentLine",
            ProdKind::CorncsP1 => "Corncs: Cornc0",
            ProdKind::Cornc1P1 => "Cornc1: Cornc1 Cornc",
            ProdKind::Cornc1P2 => "Cornc1: Cornc",
            ProdKind::Cornc0P1 => "Cornc0: Cornc1",
            ProdKind::Cornc0P2 => "Cornc0: ",
            ProdKind::CorncP1 => "Cornc: Comment",
            ProdKind::CorncP2 => "Cornc: NotComment",
            ProdKind::CorncP3 => "Cornc: WS",
        };
        write!(f, "{name}")
    }
}
#[allow(clippy::upper_case_acronyms)]
#[allow(dead_code)]
#[derive(Clone, Copy, Debug)]
pub enum NonTermKind {
    EMPTY,
    AUG,
    AUGL,
    File,
    GrammarRule1,
    ImportStm1,
    TerminalRule1,
    ImportStm,
    GrammarRule,
    AnnotationOpt,
    GrammarRuleRHS,
    Production,
    Assignment1,
    TerminalRule,
    ProdMetaData,
    ProdMetaDatas,
    TermMetaData,
    TermMetaDatas,
    UserMetaData,
    ProdKind,
    ConstVal,
    Assignment,
    PlainAssignment,
    BoolAssignment,
    ProductionGroup,
    GrammarSymbolRef,
    RepetitionOperatorOpt,
    RepetitionOperator,
    RepetitionModifiersOpt,
    RepetitionOperatorOp,
    RepetitionModifiers,
    RepetitionModifier1,
    RepetitionModifier,
    GrammarSymbol,
    Recognizer,
    Layout,
    LayoutItem1,
    LayoutItem0,
    LayoutItem,
    Comment,
    Corncs,
    Cornc1,
    Cornc0,
    Cornc,
}
impl From<ProdKind> for NonTermKind {
    fn from(prod: ProdKind) -> Self {
        match prod {
            ProdKind::FileP1 => NonTermKind::File,
            ProdKind::GrammarRule1P1 => NonTermKind::GrammarRule1,
            ProdKind::GrammarRule1P2 => NonTermKind::GrammarRule1,
            ProdKind::FileP2 => NonTermKind::File,
            ProdKind::ImportStm1P1 => NonTermKind::ImportStm1,
            ProdKind::ImportStm1P2 => NonTermKind::ImportStm1,
            ProdKind::FileP3 => NonTermKind::File,
            ProdKind::TerminalRule1P1 => NonTermKind::TerminalRule1,
            ProdKind::TerminalRule1P2 => NonTermKind::TerminalRule1,
            ProdKind::FileP4 => NonTermKind::File,
            ProdKind::FileP5 => NonTermKind::File,
            ProdKind::ImportStmP1 => NonTermKind::ImportStm,
            ProdKind::ImportStmP2 => NonTermKind::ImportStm,
            ProdKind::GrammarRuleP1 => NonTermKind::GrammarRule,
            ProdKind::AnnotationOptP1 => NonTermKind::AnnotationOpt,
            ProdKind::AnnotationOptP2 => NonTermKind::AnnotationOpt,
            ProdKind::GrammarRuleP2 => NonTermKind::GrammarRule,
            ProdKind::GrammarRuleRHSP1 => NonTermKind::GrammarRuleRHS,
            ProdKind::GrammarRuleRHSP2 => NonTermKind::GrammarRuleRHS,
            ProdKind::ProductionP1 => NonTermKind::Production,
            ProdKind::Assignment1P1 => NonTermKind::Assignment1,
            ProdKind::Assignment1P2 => NonTermKind::Assignment1,
            ProdKind::ProductionP2 => NonTermKind::Production,
            ProdKind::TerminalRuleP1 => NonTermKind::TerminalRule,
            ProdKind::TerminalRuleP2 => NonTermKind::TerminalRule,
            ProdKind::TerminalRuleP3 => NonTermKind::TerminalRule,
            ProdKind::TerminalRuleP4 => NonTermKind::TerminalRule,
            ProdKind::ProdMetaDataLeft => NonTermKind::ProdMetaData,
            ProdKind::ProdMetaDataReduce => NonTermKind::ProdMetaData,
            ProdKind::ProdMetaDataRight => NonTermKind::ProdMetaData,
            ProdKind::ProdMetaDataShift => NonTermKind::ProdMetaData,
            ProdKind::ProdMetaDataDynamic => NonTermKind::ProdMetaData,
            ProdKind::ProdMetaDataNOPS => NonTermKind::ProdMetaData,
            ProdKind::ProdMetaDataNOPSE => NonTermKind::ProdMetaData,
            ProdKind::ProdMetaDataPriority => NonTermKind::ProdMetaData,
            ProdKind::ProdMetaDataP9 => NonTermKind::ProdMetaData,
            ProdKind::ProdMetaDataP10 => NonTermKind::ProdMetaData,
            ProdKind::ProdMetaDatasP1 => NonTermKind::ProdMetaDatas,
            ProdKind::ProdMetaDatasP2 => NonTermKind::ProdMetaDatas,
            ProdKind::TermMetaDataPrefer => NonTermKind::TermMetaData,
            ProdKind::TermMetaDataFinish => NonTermKind::TermMetaData,
            ProdKind::TermMetaDataNoFinish => NonTermKind::TermMetaData,
            ProdKind::TermMetaDataLeft => NonTermKind::TermMetaData,
            ProdKind::TermMetaDataReduce => NonTermKind::TermMetaData,
            ProdKind::TermMetaDataRight => NonTermKind::TermMetaData,
            ProdKind::TermMetaDataShift => NonTermKind::TermMetaData,
            ProdKind::TermMetaDataDynamic => NonTermKind::TermMetaData,
            ProdKind::TermMetaDataPriority => NonTermKind::TermMetaData,
            ProdKind::TermMetaDataP10 => NonTermKind::TermMetaData,
            ProdKind::TermMetaDatasP1 => NonTermKind::TermMetaDatas,
            ProdKind::TermMetaDatasP2 => NonTermKind::TermMetaDatas,
            ProdKind::UserMetaDataP1 => NonTermKind::UserMetaData,
            ProdKind::ProdKindP1 => NonTermKind::ProdKind,
            ProdKind::ConstValP1 => NonTermKind::ConstVal,
            ProdKind::ConstValP2 => NonTermKind::ConstVal,
            ProdKind::ConstValP3 => NonTermKind::ConstVal,
            ProdKind::ConstValP4 => NonTermKind::ConstVal,
            ProdKind::AssignmentP1 => NonTermKind::Assignment,
            ProdKind::AssignmentP2 => NonTermKind::Assignment,
            ProdKind::AssignmentP3 => NonTermKind::Assignment,
            ProdKind::PlainAssignmentP1 => NonTermKind::PlainAssignment,
            ProdKind::BoolAssignmentP1 => NonTermKind::BoolAssignment,
            ProdKind::ProductionGroupP1 => NonTermKind::ProductionGroup,
            ProdKind::GrammarSymbolRefP1 => NonTermKind::GrammarSymbolRef,
            ProdKind::RepetitionOperatorOptP1 => NonTermKind::RepetitionOperatorOpt,
            ProdKind::RepetitionOperatorOptP2 => NonTermKind::RepetitionOperatorOpt,
            ProdKind::GrammarSymbolRefP2 => NonTermKind::GrammarSymbolRef,
            ProdKind::RepetitionOperatorP1 => NonTermKind::RepetitionOperator,
            ProdKind::RepetitionModifiersOptP1 => NonTermKind::RepetitionModifiersOpt,
            ProdKind::RepetitionModifiersOptP2 => NonTermKind::RepetitionModifiersOpt,
            ProdKind::RepetitionOperatorOpZeroOrMore => NonTermKind::RepetitionOperatorOp,
            ProdKind::RepetitionOperatorOpZeroOrMoreGreedy => {
                NonTermKind::RepetitionOperatorOp
            }
            ProdKind::RepetitionOperatorOpOneOrMore => NonTermKind::RepetitionOperatorOp,
            ProdKind::RepetitionOperatorOpOneOrMoreGreedy => {
                NonTermKind::RepetitionOperatorOp
            }
            ProdKind::RepetitionOperatorOpOptional => NonTermKind::RepetitionOperatorOp,
            ProdKind::RepetitionOperatorOpOptionalGreedy => {
                NonTermKind::RepetitionOperatorOp
            }
            ProdKind::RepetitionModifiersP1 => NonTermKind::RepetitionModifiers,
            ProdKind::RepetitionModifier1P1 => NonTermKind::RepetitionModifier1,
            ProdKind::RepetitionModifier1P2 => NonTermKind::RepetitionModifier1,
            ProdKind::RepetitionModifierP1 => NonTermKind::RepetitionModifier,
            ProdKind::GrammarSymbolP1 => NonTermKind::GrammarSymbol,
            ProdKind::GrammarSymbolP2 => NonTermKind::GrammarSymbol,
            ProdKind::RecognizerP1 => NonTermKind::Recognizer,
            ProdKind::RecognizerP2 => NonTermKind::Recognizer,
            ProdKind::LayoutP1 => NonTermKind::Layout,
            ProdKind::LayoutItem1P1 => NonTermKind::LayoutItem1,
            ProdKind::LayoutItem1P2 => NonTermKind::LayoutItem1,
            ProdKind::LayoutItem0P1 => NonTermKind::LayoutItem0,
            ProdKind::LayoutItem0P2 => NonTermKind::LayoutItem0,
            ProdKind::LayoutItemP1 => NonTermKind::LayoutItem,
            ProdKind::LayoutItemP2 => NonTermKind::LayoutItem,
            ProdKind::CommentP1 => NonTermKind::Comment,
            ProdKind::CommentP2 => NonTermKind::Comment,
            ProdKind::CorncsP1 => NonTermKind::Corncs,
            ProdKind::Cornc1P1 => NonTermKind::Cornc1,
            ProdKind::Cornc1P2 => NonTermKind::Cornc1,
            ProdKind::Cornc0P1 => NonTermKind::Cornc0,
            ProdKind::Cornc0P2 => NonTermKind::Cornc0,
            ProdKind::CorncP1 => NonTermKind::Cornc,
            ProdKind::CorncP2 => NonTermKind::Cornc,
            ProdKind::CorncP3 => NonTermKind::Cornc,
        }
    }
}
#[allow(clippy::enum_variant_names)]
#[derive(Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum State {
    #[default]
    AUGS0,
    TerminalsS1,
    ImportS2,
    AnnotationS3,
    FileS4,
    GrammarRule1S5,
    ImportStm1S6,
    ImportStmS7,
    GrammarRuleS8,
    AnnotationOptS9,
    TerminalRule1S10,
    AnnotationOptS11,
    TerminalRuleS12,
    StrConstS13,
    TerminalsS14,
    GrammarRuleS15,
    GrammarRule1S16,
    ImportStmS17,
    NameS18,
    TerminalRuleS19,
    NameS20,
    AsS21,
    TerminalRule1S22,
    TerminalsS23,
    ColonS24,
    OBraceS25,
    ColonS26,
    NameS27,
    TerminalRule1S28,
    OBracketS29,
    NameS30,
    StrConstS31,
    GrammarRuleRHSS32,
    ProductionS33,
    Assignment1S34,
    AssignmentS35,
    PlainAssignmentS36,
    BoolAssignmentS37,
    ProductionGroupS38,
    GrammarSymbolRefS39,
    GrammarSymbolS40,
    LeftS41,
    RightS42,
    ReduceS43,
    ShiftS44,
    DynamicS45,
    NOPSS46,
    NOPSES47,
    NameS48,
    IntConstS49,
    ProdMetaDataS50,
    ProdMetaDatasS51,
    UserMetaDataS52,
    ProdKindS53,
    SemiColonS54,
    OBraceS55,
    RegexTermS56,
    StrConstS57,
    RecognizerS58,
    GrammarRuleRHSS59,
    EqualsS60,
    QEqualsS61,
    SemiColonS62,
    ChoiceS63,
    OBraceS64,
    AssignmentS65,
    ZeroOrMoreS66,
    ZeroOrMoreGreedyS67,
    OneOrMoreS68,
    OneOrMoreGreedyS69,
    OptionalS70,
    OptionalGreedyS71,
    RepetitionOperatorOptS72,
    RepetitionOperatorS73,
    RepetitionOperatorOpS74,
    RepetitionOperatorOptS75,
    ColonS76,
    CommaS77,
    CBraceS78,
    LeftS79,
    RightS80,
    ReduceS81,
    ShiftS82,
    DynamicS83,
    PreferS84,
    FinishS85,
    NoFinishS86,
    NameS87,
    IntConstS88,
    TermMetaDataS89,
    TermMetaDatasS90,
    UserMetaDataS91,
    SemiColonS92,
    OBraceS93,
    CBracketS94,
    NameS95,
    GrammarSymbolRefS96,
    GrammarSymbolRefS97,
    ProductionS98,
    ProdMetaDatasS99,
    OSBracketS100,
    RepetitionModifiersOptS101,
    RepetitionModifiersS102,
    IntConstS103,
    FloatConstS104,
    BoolConstS105,
    StrConstS106,
    ConstValS107,
    ProdMetaDataS108,
    ColonS109,
    CommaS110,
    CBraceS111,
    TermMetaDatasS112,
    CBraceS113,
    NameS114,
    RepetitionModifier1S115,
    RepetitionModifierS116,
    GrammarRuleRHSS117,
    TermMetaDataS118,
    SemiColonS119,
    CBraceS120,
    CommaS121,
    CSBracketS122,
    SemiColonS123,
    SemiColonS124,
    RepetitionModifierS125,
    AUGLS126,
    OCommentS127,
    WSS128,
    CommentLineS129,
    LayoutS130,
    LayoutItem1S131,
    LayoutItem0S132,
    LayoutItemS133,
    CommentS134,
    WSS135,
    NotCommentS136,
    CommentS137,
    CorncsS138,
    Cornc1S139,
    Cornc0S140,
    CorncS141,
    LayoutItemS142,
    CCommentS143,
    CorncS144,
}
impl StateT for State {
    fn default_layout() -> Option<Self> {
        Some(State::AUGLS126)
    }
}
impl From<State> for usize {
    fn from(s: State) -> Self {
        s as usize
    }
}
impl std::fmt::Debug for State {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let name = match self {
            State::AUGS0 => "0:AUG",
            State::TerminalsS1 => "1:Terminals",
            State::ImportS2 => "2:Import",
            State::AnnotationS3 => "3:Annotation",
            State::FileS4 => "4:File",
            State::GrammarRule1S5 => "5:GrammarRule1",
            State::ImportStm1S6 => "6:ImportStm1",
            State::ImportStmS7 => "7:ImportStm",
            State::GrammarRuleS8 => "8:GrammarRule",
            State::AnnotationOptS9 => "9:AnnotationOpt",
            State::TerminalRule1S10 => "10:TerminalRule1",
            State::AnnotationOptS11 => "11:AnnotationOpt",
            State::TerminalRuleS12 => "12:TerminalRule",
            State::StrConstS13 => "13:StrConst",
            State::TerminalsS14 => "14:Terminals",
            State::GrammarRuleS15 => "15:GrammarRule",
            State::GrammarRule1S16 => "16:GrammarRule1",
            State::ImportStmS17 => "17:ImportStm",
            State::NameS18 => "18:Name",
            State::TerminalRuleS19 => "19:TerminalRule",
            State::NameS20 => "20:Name",
            State::AsS21 => "21:As",
            State::TerminalRule1S22 => "22:TerminalRule1",
            State::TerminalsS23 => "23:Terminals",
            State::ColonS24 => "24:Colon",
            State::OBraceS25 => "25:OBrace",
            State::ColonS26 => "26:Colon",
            State::NameS27 => "27:Name",
            State::TerminalRule1S28 => "28:TerminalRule1",
            State::OBracketS29 => "29:OBracket",
            State::NameS30 => "30:Name",
            State::StrConstS31 => "31:StrConst",
            State::GrammarRuleRHSS32 => "32:GrammarRuleRHS",
            State::ProductionS33 => "33:Production",
            State::Assignment1S34 => "34:Assignment1",
            State::AssignmentS35 => "35:Assignment",
            State::PlainAssignmentS36 => "36:PlainAssignment",
            State::BoolAssignmentS37 => "37:BoolAssignment",
            State::ProductionGroupS38 => "38:ProductionGroup",
            State::GrammarSymbolRefS39 => "39:GrammarSymbolRef",
            State::GrammarSymbolS40 => "40:GrammarSymbol",
            State::LeftS41 => "41:Left",
            State::RightS42 => "42:Right",
            State::ReduceS43 => "43:Reduce",
            State::ShiftS44 => "44:Shift",
            State::DynamicS45 => "45:Dynamic",
            State::NOPSS46 => "46:NOPS",
            State::NOPSES47 => "47:NOPSE",
            State::NameS48 => "48:Name",
            State::IntConstS49 => "49:IntConst",
            State::ProdMetaDataS50 => "50:ProdMetaData",
            State::ProdMetaDatasS51 => "51:ProdMetaDatas",
            State::UserMetaDataS52 => "52:UserMetaData",
            State::ProdKindS53 => "53:ProdKind",
            State::SemiColonS54 => "54:SemiColon",
            State::OBraceS55 => "55:OBrace",
            State::RegexTermS56 => "56:RegexTerm",
            State::StrConstS57 => "57:StrConst",
            State::RecognizerS58 => "58:Recognizer",
            State::GrammarRuleRHSS59 => "59:GrammarRuleRHS",
            State::EqualsS60 => "60:Equals",
            State::QEqualsS61 => "61:QEquals",
            State::SemiColonS62 => "62:SemiColon",
            State::ChoiceS63 => "63:Choice",
            State::OBraceS64 => "64:OBrace",
            State::AssignmentS65 => "65:Assignment",
            State::ZeroOrMoreS66 => "66:ZeroOrMore",
            State::ZeroOrMoreGreedyS67 => "67:ZeroOrMoreGreedy",
            State::OneOrMoreS68 => "68:OneOrMore",
            State::OneOrMoreGreedyS69 => "69:OneOrMoreGreedy",
            State::OptionalS70 => "70:Optional",
            State::OptionalGreedyS71 => "71:OptionalGreedy",
            State::RepetitionOperatorOptS72 => "72:RepetitionOperatorOpt",
            State::RepetitionOperatorS73 => "73:RepetitionOperator",
            State::RepetitionOperatorOpS74 => "74:RepetitionOperatorOp",
            State::RepetitionOperatorOptS75 => "75:RepetitionOperatorOpt",
            State::ColonS76 => "76:Colon",
            State::CommaS77 => "77:Comma",
            State::CBraceS78 => "78:CBrace",
            State::LeftS79 => "79:Left",
            State::RightS80 => "80:Right",
            State::ReduceS81 => "81:Reduce",
            State::ShiftS82 => "82:Shift",
            State::DynamicS83 => "83:Dynamic",
            State::PreferS84 => "84:Prefer",
            State::FinishS85 => "85:Finish",
            State::NoFinishS86 => "86:NoFinish",
            State::NameS87 => "87:Name",
            State::IntConstS88 => "88:IntConst",
            State::TermMetaDataS89 => "89:TermMetaData",
            State::TermMetaDatasS90 => "90:TermMetaDatas",
            State::UserMetaDataS91 => "91:UserMetaData",
            State::SemiColonS92 => "92:SemiColon",
            State::OBraceS93 => "93:OBrace",
            State::CBracketS94 => "94:CBracket",
            State::NameS95 => "95:Name",
            State::GrammarSymbolRefS96 => "96:GrammarSymbolRef",
            State::GrammarSymbolRefS97 => "97:GrammarSymbolRef",
            State::ProductionS98 => "98:Production",
            State::ProdMetaDatasS99 => "99:ProdMetaDatas",
            State::OSBracketS100 => "100:OSBracket",
            State::RepetitionModifiersOptS101 => "101:RepetitionModifiersOpt",
            State::RepetitionModifiersS102 => "102:RepetitionModifiers",
            State::IntConstS103 => "103:IntConst",
            State::FloatConstS104 => "104:FloatConst",
            State::BoolConstS105 => "105:BoolConst",
            State::StrConstS106 => "106:StrConst",
            State::ConstValS107 => "107:ConstVal",
            State::ProdMetaDataS108 => "108:ProdMetaData",
            State::ColonS109 => "109:Colon",
            State::CommaS110 => "110:Comma",
            State::CBraceS111 => "111:CBrace",
            State::TermMetaDatasS112 => "112:TermMetaDatas",
            State::CBraceS113 => "113:CBrace",
            State::NameS114 => "114:Name",
            State::RepetitionModifier1S115 => "115:RepetitionModifier1",
            State::RepetitionModifierS116 => "116:RepetitionModifier",
            State::GrammarRuleRHSS117 => "117:GrammarRuleRHS",
            State::TermMetaDataS118 => "118:TermMetaData",
            State::SemiColonS119 => "119:SemiColon",
            State::CBraceS120 => "120:CBrace",
            State::CommaS121 => "121:Comma",
            State::CSBracketS122 => "122:CSBracket",
            State::SemiColonS123 => "123:SemiColon",
            State::SemiColonS124 => "124:SemiColon",
            State::RepetitionModifierS125 => "125:RepetitionModifier",
            State::AUGLS126 => "126:AUGL",
            State::OCommentS127 => "127:OComment",
            State::WSS128 => "128:WS",
            State::CommentLineS129 => "129:CommentLine",
            State::LayoutS130 => "130:Layout",
            State::LayoutItem1S131 => "131:LayoutItem1",
            State::LayoutItem0S132 => "132:LayoutItem0",
            State::LayoutItemS133 => "133:LayoutItem",
            State::CommentS134 => "134:Comment",
            State::WSS135 => "135:WS",
            State::NotCommentS136 => "136:NotComment",
            State::CommentS137 => "137:Comment",
            State::CorncsS138 => "138:Corncs",
            State::Cornc1S139 => "139:Cornc1",
            State::Cornc0S140 => "140:Cornc0",
            State::CorncS141 => "141:Cornc",
            State::LayoutItemS142 => "142:LayoutItem",
            State::CCommentS143 => "143:CComment",
            State::CorncS144 => "144:Cornc",
        };
        write!(f, "{name}")
    }
}
#[derive(Debug)]
pub enum Symbol {
    Terminal(Terminal),
    NonTerminal(NonTerminal),
}
#[allow(clippy::upper_case_acronyms)]
#[derive(Debug)]
pub enum Terminal {
    Terminals,
    Import,
    As,
    Colon,
    SemiColon,
    Comma,
    OBrace,
    CBrace,
    OBracket,
    CBracket,
    OSBracket,
    CSBracket,
    Choice,
    ZeroOrMore,
    ZeroOrMoreGreedy,
    OneOrMore,
    OneOrMoreGreedy,
    Optional,
    OptionalGreedy,
    Equals,
    QEquals,
    Left,
    Right,
    Reduce,
    Shift,
    Dynamic,
    NOPS,
    NOPSE,
    Prefer,
    Finish,
    NoFinish,
    Name(rustemo_actions::Name),
    RegexTerm(rustemo_actions::RegexTerm),
    IntConst(rustemo_actions::IntConst),
    FloatConst(rustemo_actions::FloatConst),
    BoolConst(rustemo_actions::BoolConst),
    StrConst(rustemo_actions::StrConst),
    Annotation(rustemo_actions::Annotation),
}
#[derive(Debug)]
pub enum NonTerminal {
    File(rustemo_actions::File),
    GrammarRule1(rustemo_actions::GrammarRule1),
    ImportStm1(rustemo_actions::ImportStm1),
    TerminalRule1(rustemo_actions::TerminalRule1),
    ImportStm(rustemo_actions::ImportStm),
    GrammarRule(rustemo_actions::GrammarRule),
    AnnotationOpt(rustemo_actions::AnnotationOpt),
    GrammarRuleRHS(rustemo_actions::GrammarRuleRHS),
    Production(rustemo_actions::Production),
    Assignment1(rustemo_actions::Assignment1),
    TerminalRule(rustemo_actions::TerminalRule),
    ProdMetaData(rustemo_actions::ProdMetaData),
    ProdMetaDatas(rustemo_actions::ProdMetaDatas),
    TermMetaData(rustemo_actions::TermMetaData),
    TermMetaDatas(rustemo_actions::TermMetaDatas),
    UserMetaData(rustemo_actions::UserMetaData),
    ProdKind(rustemo_actions::ProdKind),
    ConstVal(rustemo_actions::ConstVal),
    Assignment(rustemo_actions::Assignment),
    PlainAssignment(rustemo_actions::PlainAssignment),
    BoolAssignment(rustemo_actions::BoolAssignment),
    ProductionGroup(rustemo_actions::ProductionGroup),
    GrammarSymbolRef(rustemo_actions::GrammarSymbolRef),
    RepetitionOperatorOpt(rustemo_actions::RepetitionOperatorOpt),
    RepetitionOperator(rustemo_actions::RepetitionOperator),
    RepetitionModifiersOpt(rustemo_actions::RepetitionModifiersOpt),
    RepetitionOperatorOp(rustemo_actions::RepetitionOperatorOp),
    RepetitionModifiers(rustemo_actions::RepetitionModifiers),
    RepetitionModifier1(rustemo_actions::RepetitionModifier1),
    RepetitionModifier(rustemo_actions::RepetitionModifier),
    GrammarSymbol(rustemo_actions::GrammarSymbol),
    Recognizer(rustemo_actions::Recognizer),
}
type ActionFn = fn(token: TokenKind) -> Vec<Action<State, ProdKind>>;
pub struct RustemoParserDefinition {
    actions: [ActionFn; STATE_COUNT],
    gotos: [fn(nonterm: NonTermKind) -> State; STATE_COUNT],
    token_kinds: [[Option<(TokenKind, bool)>; MAX_RECOGNIZERS]; STATE_COUNT],
}
fn action_aug_s0(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Terminals => Vec::from(&[Shift(State::TerminalsS1)]),
        TK::Import => Vec::from(&[Shift(State::ImportS2)]),
        TK::Name => Vec::from(&[Reduce(PK::AnnotationOptP2, 0usize)]),
        TK::Annotation => Vec::from(&[Shift(State::AnnotationS3)]),
        _ => vec![],
    }
}
fn action_terminals_s1(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Name => Vec::from(&[Reduce(PK::AnnotationOptP2, 0usize)]),
        TK::Annotation => Vec::from(&[Shift(State::AnnotationS3)]),
        _ => vec![],
    }
}
fn action_import_s2(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::StrConst => Vec::from(&[Shift(State::StrConstS13)]),
        _ => vec![],
    }
}
fn action_annotation_s3(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Name => Vec::from(&[Reduce(PK::AnnotationOptP1, 1usize)]),
        _ => vec![],
    }
}
fn action_file_s4(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Accept]),
        _ => vec![],
    }
}
fn action_grammarrule1_s5(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::FileP1, 1usize)]),
        TK::Terminals => Vec::from(&[Shift(State::TerminalsS14)]),
        TK::Name => Vec::from(&[Reduce(PK::AnnotationOptP2, 0usize)]),
        TK::Annotation => Vec::from(&[Shift(State::AnnotationS3)]),
        _ => vec![],
    }
}
fn action_importstm1_s6(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Import => Vec::from(&[Shift(State::ImportS2)]),
        TK::Name => Vec::from(&[Reduce(PK::AnnotationOptP2, 0usize)]),
        TK::Annotation => Vec::from(&[Shift(State::AnnotationS3)]),
        _ => vec![],
    }
}
fn action_importstm_s7(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Import => Vec::from(&[Reduce(PK::ImportStm1P2, 1usize)]),
        TK::Name => Vec::from(&[Reduce(PK::ImportStm1P2, 1usize)]),
        TK::Annotation => Vec::from(&[Reduce(PK::ImportStm1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_grammarrule_s8(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::GrammarRule1P2, 1usize)]),
        TK::Terminals => Vec::from(&[Reduce(PK::GrammarRule1P2, 1usize)]),
        TK::Name => Vec::from(&[Reduce(PK::GrammarRule1P2, 1usize)]),
        TK::Annotation => Vec::from(&[Reduce(PK::GrammarRule1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_annotationopt_s9(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Name => Vec::from(&[Shift(State::NameS18)]),
        _ => vec![],
    }
}
fn action_terminalrule1_s10(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::FileP5, 2usize)]),
        TK::Name => Vec::from(&[Reduce(PK::AnnotationOptP2, 0usize)]),
        TK::Annotation => Vec::from(&[Shift(State::AnnotationS3)]),
        _ => vec![],
    }
}
fn action_annotationopt_s11(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Name => Vec::from(&[Shift(State::NameS20)]),
        _ => vec![],
    }
}
fn action_terminalrule_s12(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::TerminalRule1P2, 1usize)]),
        TK::Name => Vec::from(&[Reduce(PK::TerminalRule1P2, 1usize)]),
        TK::Annotation => Vec::from(&[Reduce(PK::TerminalRule1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_strconst_s13(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Import => Vec::from(&[Reduce(PK::ImportStmP1, 2usize)]),
        TK::As => Vec::from(&[Shift(State::AsS21)]),
        TK::Name => Vec::from(&[Reduce(PK::ImportStmP1, 2usize)]),
        TK::Annotation => Vec::from(&[Reduce(PK::ImportStmP1, 2usize)]),
        _ => vec![],
    }
}
fn action_terminals_s14(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Name => Vec::from(&[Reduce(PK::AnnotationOptP2, 0usize)]),
        TK::Annotation => Vec::from(&[Shift(State::AnnotationS3)]),
        _ => vec![],
    }
}
fn action_grammarrule_s15(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::GrammarRule1P1, 2usize)]),
        TK::Terminals => Vec::from(&[Reduce(PK::GrammarRule1P1, 2usize)]),
        TK::Name => Vec::from(&[Reduce(PK::GrammarRule1P1, 2usize)]),
        TK::Annotation => Vec::from(&[Reduce(PK::GrammarRule1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_grammarrule1_s16(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::FileP2, 2usize)]),
        TK::Terminals => Vec::from(&[Shift(State::TerminalsS23)]),
        TK::Name => Vec::from(&[Reduce(PK::AnnotationOptP2, 0usize)]),
        TK::Annotation => Vec::from(&[Shift(State::AnnotationS3)]),
        _ => vec![],
    }
}
fn action_importstm_s17(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Import => Vec::from(&[Reduce(PK::ImportStm1P1, 2usize)]),
        TK::Name => Vec::from(&[Reduce(PK::ImportStm1P1, 2usize)]),
        TK::Annotation => Vec::from(&[Reduce(PK::ImportStm1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_name_s18(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Colon => Vec::from(&[Shift(State::ColonS24)]),
        TK::OBrace => Vec::from(&[Shift(State::OBraceS25)]),
        _ => vec![],
    }
}
fn action_terminalrule_s19(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::TerminalRule1P1, 2usize)]),
        TK::Name => Vec::from(&[Reduce(PK::TerminalRule1P1, 2usize)]),
        TK::Annotation => Vec::from(&[Reduce(PK::TerminalRule1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_name_s20(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Colon => Vec::from(&[Shift(State::ColonS26)]),
        _ => vec![],
    }
}
fn action_as_s21(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Name => Vec::from(&[Shift(State::NameS27)]),
        _ => vec![],
    }
}
fn action_terminalrule1_s22(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::FileP3, 3usize)]),
        TK::Name => Vec::from(&[Reduce(PK::AnnotationOptP2, 0usize)]),
        TK::Annotation => Vec::from(&[Shift(State::AnnotationS3)]),
        _ => vec![],
    }
}
fn action_terminals_s23(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Name => Vec::from(&[Reduce(PK::AnnotationOptP2, 0usize)]),
        TK::Annotation => Vec::from(&[Shift(State::AnnotationS3)]),
        _ => vec![],
    }
}
fn action_colon_s24(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OBracket => Vec::from(&[Shift(State::OBracketS29)]),
        TK::Name => Vec::from(&[Shift(State::NameS30)]),
        TK::StrConst => Vec::from(&[Shift(State::StrConstS31)]),
        _ => vec![],
    }
}
fn action_obrace_s25(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Left => Vec::from(&[Shift(State::LeftS41)]),
        TK::Right => Vec::from(&[Shift(State::RightS42)]),
        TK::Reduce => Vec::from(&[Shift(State::ReduceS43)]),
        TK::Shift => Vec::from(&[Shift(State::ShiftS44)]),
        TK::Dynamic => Vec::from(&[Shift(State::DynamicS45)]),
        TK::NOPS => Vec::from(&[Shift(State::NOPSS46)]),
        TK::NOPSE => Vec::from(&[Shift(State::NOPSES47)]),
        TK::Name => Vec::from(&[Shift(State::NameS48)]),
        TK::IntConst => Vec::from(&[Shift(State::IntConstS49)]),
        _ => vec![],
    }
}
fn action_colon_s26(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Shift(State::SemiColonS54)]),
        TK::OBrace => Vec::from(&[Shift(State::OBraceS55)]),
        TK::RegexTerm => Vec::from(&[Shift(State::RegexTermS56)]),
        TK::StrConst => Vec::from(&[Shift(State::StrConstS57)]),
        _ => vec![],
    }
}
fn action_name_s27(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Import => Vec::from(&[Reduce(PK::ImportStmP2, 4usize)]),
        TK::Name => Vec::from(&[Reduce(PK::ImportStmP2, 4usize)]),
        TK::Annotation => Vec::from(&[Reduce(PK::ImportStmP2, 4usize)]),
        _ => vec![],
    }
}
fn action_terminalrule1_s28(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::FileP4, 4usize)]),
        TK::Name => Vec::from(&[Reduce(PK::AnnotationOptP2, 0usize)]),
        TK::Annotation => Vec::from(&[Shift(State::AnnotationS3)]),
        _ => vec![],
    }
}
fn action_obracket_s29(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OBracket => Vec::from(&[Shift(State::OBracketS29)]),
        TK::Name => Vec::from(&[Shift(State::NameS30)]),
        TK::StrConst => Vec::from(&[Shift(State::StrConstS31)]),
        _ => vec![],
    }
}
fn action_name_s30(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::ZeroOrMore => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::ZeroOrMoreGreedy => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::OneOrMore => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::OneOrMoreGreedy => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::Optional => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::OptionalGreedy => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::Equals => Vec::from(&[Shift(State::EqualsS60)]),
        TK::QEquals => Vec::from(&[Shift(State::QEqualsS61)]),
        TK::Name => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        _ => vec![],
    }
}
fn action_strconst_s31(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::GrammarSymbolP2, 1usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::GrammarSymbolP2, 1usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::GrammarSymbolP2, 1usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::GrammarSymbolP2, 1usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::GrammarSymbolP2, 1usize)]),
        TK::ZeroOrMore => Vec::from(&[Reduce(PK::GrammarSymbolP2, 1usize)]),
        TK::ZeroOrMoreGreedy => Vec::from(&[Reduce(PK::GrammarSymbolP2, 1usize)]),
        TK::OneOrMore => Vec::from(&[Reduce(PK::GrammarSymbolP2, 1usize)]),
        TK::OneOrMoreGreedy => Vec::from(&[Reduce(PK::GrammarSymbolP2, 1usize)]),
        TK::Optional => Vec::from(&[Reduce(PK::GrammarSymbolP2, 1usize)]),
        TK::OptionalGreedy => Vec::from(&[Reduce(PK::GrammarSymbolP2, 1usize)]),
        TK::Name => Vec::from(&[Reduce(PK::GrammarSymbolP2, 1usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::GrammarSymbolP2, 1usize)]),
        _ => vec![],
    }
}
fn action_grammarrulerhs_s32(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Shift(State::SemiColonS62)]),
        TK::Choice => Vec::from(&[Shift(State::ChoiceS63)]),
        _ => vec![],
    }
}
fn action_production_s33(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::GrammarRuleRHSP2, 1usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::GrammarRuleRHSP2, 1usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::GrammarRuleRHSP2, 1usize)]),
        _ => vec![],
    }
}
fn action_assignment1_s34(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::ProductionP1, 1usize)]),
        TK::OBrace => Vec::from(&[Shift(State::OBraceS64)]),
        TK::OBracket => Vec::from(&[Shift(State::OBracketS29)]),
        TK::CBracket => Vec::from(&[Reduce(PK::ProductionP1, 1usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::ProductionP1, 1usize)]),
        TK::Name => Vec::from(&[Shift(State::NameS30)]),
        TK::StrConst => Vec::from(&[Shift(State::StrConstS31)]),
        _ => vec![],
    }
}
fn action_assignment_s35(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::Assignment1P2, 1usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::Assignment1P2, 1usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::Assignment1P2, 1usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::Assignment1P2, 1usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::Assignment1P2, 1usize)]),
        TK::Name => Vec::from(&[Reduce(PK::Assignment1P2, 1usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::Assignment1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_plainassignment_s36(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::AssignmentP1, 1usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::AssignmentP1, 1usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::AssignmentP1, 1usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::AssignmentP1, 1usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::AssignmentP1, 1usize)]),
        TK::Name => Vec::from(&[Reduce(PK::AssignmentP1, 1usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::AssignmentP1, 1usize)]),
        _ => vec![],
    }
}
fn action_boolassignment_s37(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::AssignmentP2, 1usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::AssignmentP2, 1usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::AssignmentP2, 1usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::AssignmentP2, 1usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::AssignmentP2, 1usize)]),
        TK::Name => Vec::from(&[Reduce(PK::AssignmentP2, 1usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::AssignmentP2, 1usize)]),
        _ => vec![],
    }
}
fn action_productiongroup_s38(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::RepetitionOperatorOptP2, 0usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::RepetitionOperatorOptP2, 0usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::RepetitionOperatorOptP2, 0usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::RepetitionOperatorOptP2, 0usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::RepetitionOperatorOptP2, 0usize)]),
        TK::ZeroOrMore => Vec::from(&[Shift(State::ZeroOrMoreS66)]),
        TK::ZeroOrMoreGreedy => Vec::from(&[Shift(State::ZeroOrMoreGreedyS67)]),
        TK::OneOrMore => Vec::from(&[Shift(State::OneOrMoreS68)]),
        TK::OneOrMoreGreedy => Vec::from(&[Shift(State::OneOrMoreGreedyS69)]),
        TK::Optional => Vec::from(&[Shift(State::OptionalS70)]),
        TK::OptionalGreedy => Vec::from(&[Shift(State::OptionalGreedyS71)]),
        TK::Name => Vec::from(&[Reduce(PK::RepetitionOperatorOptP2, 0usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::RepetitionOperatorOptP2, 0usize)]),
        _ => vec![],
    }
}
fn action_grammarsymbolref_s39(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::AssignmentP3, 1usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::AssignmentP3, 1usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::AssignmentP3, 1usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::AssignmentP3, 1usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::AssignmentP3, 1usize)]),
        TK::Name => Vec::from(&[Reduce(PK::AssignmentP3, 1usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::AssignmentP3, 1usize)]),
        _ => vec![],
    }
}
fn action_grammarsymbol_s40(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::RepetitionOperatorOptP2, 0usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::RepetitionOperatorOptP2, 0usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::RepetitionOperatorOptP2, 0usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::RepetitionOperatorOptP2, 0usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::RepetitionOperatorOptP2, 0usize)]),
        TK::ZeroOrMore => Vec::from(&[Shift(State::ZeroOrMoreS66)]),
        TK::ZeroOrMoreGreedy => Vec::from(&[Shift(State::ZeroOrMoreGreedyS67)]),
        TK::OneOrMore => Vec::from(&[Shift(State::OneOrMoreS68)]),
        TK::OneOrMoreGreedy => Vec::from(&[Shift(State::OneOrMoreGreedyS69)]),
        TK::Optional => Vec::from(&[Shift(State::OptionalS70)]),
        TK::OptionalGreedy => Vec::from(&[Shift(State::OptionalGreedyS71)]),
        TK::Name => Vec::from(&[Reduce(PK::RepetitionOperatorOptP2, 0usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::RepetitionOperatorOptP2, 0usize)]),
        _ => vec![],
    }
}
fn action_left_s41(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ProdMetaDataLeft, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ProdMetaDataLeft, 1usize)]),
        _ => vec![],
    }
}
fn action_right_s42(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ProdMetaDataRight, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ProdMetaDataRight, 1usize)]),
        _ => vec![],
    }
}
fn action_reduce_s43(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ProdMetaDataReduce, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ProdMetaDataReduce, 1usize)]),
        _ => vec![],
    }
}
fn action_shift_s44(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ProdMetaDataShift, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ProdMetaDataShift, 1usize)]),
        _ => vec![],
    }
}
fn action_dynamic_s45(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ProdMetaDataDynamic, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ProdMetaDataDynamic, 1usize)]),
        _ => vec![],
    }
}
fn action_nops_s46(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ProdMetaDataNOPS, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ProdMetaDataNOPS, 1usize)]),
        _ => vec![],
    }
}
fn action_nopse_s47(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ProdMetaDataNOPSE, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ProdMetaDataNOPSE, 1usize)]),
        _ => vec![],
    }
}
fn action_name_s48(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Colon => Vec::from(&[Shift(State::ColonS76)]),
        TK::Comma => Vec::from(&[Reduce(PK::ProdKindP1, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ProdKindP1, 1usize)]),
        _ => vec![],
    }
}
fn action_intconst_s49(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ProdMetaDataPriority, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ProdMetaDataPriority, 1usize)]),
        _ => vec![],
    }
}
fn action_prodmetadata_s50(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ProdMetaDatasP2, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ProdMetaDatasP2, 1usize)]),
        _ => vec![],
    }
}
fn action_prodmetadatas_s51(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Shift(State::CommaS77)]),
        TK::CBrace => Vec::from(&[Shift(State::CBraceS78)]),
        _ => vec![],
    }
}
fn action_usermetadata_s52(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ProdMetaDataP9, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ProdMetaDataP9, 1usize)]),
        _ => vec![],
    }
}
fn action_prodkind_s53(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ProdMetaDataP10, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ProdMetaDataP10, 1usize)]),
        _ => vec![],
    }
}
fn action_semicolon_s54(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::TerminalRuleP2, 4usize)]),
        TK::Name => Vec::from(&[Reduce(PK::TerminalRuleP2, 4usize)]),
        TK::Annotation => Vec::from(&[Reduce(PK::TerminalRuleP2, 4usize)]),
        _ => vec![],
    }
}
fn action_obrace_s55(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Left => Vec::from(&[Shift(State::LeftS79)]),
        TK::Right => Vec::from(&[Shift(State::RightS80)]),
        TK::Reduce => Vec::from(&[Shift(State::ReduceS81)]),
        TK::Shift => Vec::from(&[Shift(State::ShiftS82)]),
        TK::Dynamic => Vec::from(&[Shift(State::DynamicS83)]),
        TK::Prefer => Vec::from(&[Shift(State::PreferS84)]),
        TK::Finish => Vec::from(&[Shift(State::FinishS85)]),
        TK::NoFinish => Vec::from(&[Shift(State::NoFinishS86)]),
        TK::Name => Vec::from(&[Shift(State::NameS87)]),
        TK::IntConst => Vec::from(&[Shift(State::IntConstS88)]),
        _ => vec![],
    }
}
fn action_regexterm_s56(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::RecognizerP2, 1usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::RecognizerP2, 1usize)]),
        _ => vec![],
    }
}
fn action_strconst_s57(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::RecognizerP1, 1usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::RecognizerP1, 1usize)]),
        _ => vec![],
    }
}
fn action_recognizer_s58(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Shift(State::SemiColonS92)]),
        TK::OBrace => Vec::from(&[Shift(State::OBraceS93)]),
        _ => vec![],
    }
}
fn action_grammarrulerhs_s59(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CBracket => Vec::from(&[Shift(State::CBracketS94)]),
        TK::Choice => Vec::from(&[Shift(State::ChoiceS63)]),
        _ => vec![],
    }
}
fn action_equals_s60(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OBracket => Vec::from(&[Shift(State::OBracketS29)]),
        TK::Name => Vec::from(&[Shift(State::NameS95)]),
        TK::StrConst => Vec::from(&[Shift(State::StrConstS31)]),
        _ => vec![],
    }
}
fn action_qequals_s61(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OBracket => Vec::from(&[Shift(State::OBracketS29)]),
        TK::Name => Vec::from(&[Shift(State::NameS95)]),
        TK::StrConst => Vec::from(&[Shift(State::StrConstS31)]),
        _ => vec![],
    }
}
fn action_semicolon_s62(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::GrammarRuleP1, 5usize)]),
        TK::Terminals => Vec::from(&[Reduce(PK::GrammarRuleP1, 5usize)]),
        TK::Name => Vec::from(&[Reduce(PK::GrammarRuleP1, 5usize)]),
        TK::Annotation => Vec::from(&[Reduce(PK::GrammarRuleP1, 5usize)]),
        _ => vec![],
    }
}
fn action_choice_s63(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OBracket => Vec::from(&[Shift(State::OBracketS29)]),
        TK::Name => Vec::from(&[Shift(State::NameS30)]),
        TK::StrConst => Vec::from(&[Shift(State::StrConstS31)]),
        _ => vec![],
    }
}
fn action_obrace_s64(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Left => Vec::from(&[Shift(State::LeftS41)]),
        TK::Right => Vec::from(&[Shift(State::RightS42)]),
        TK::Reduce => Vec::from(&[Shift(State::ReduceS43)]),
        TK::Shift => Vec::from(&[Shift(State::ShiftS44)]),
        TK::Dynamic => Vec::from(&[Shift(State::DynamicS45)]),
        TK::NOPS => Vec::from(&[Shift(State::NOPSS46)]),
        TK::NOPSE => Vec::from(&[Shift(State::NOPSES47)]),
        TK::Name => Vec::from(&[Shift(State::NameS48)]),
        TK::IntConst => Vec::from(&[Shift(State::IntConstS49)]),
        _ => vec![],
    }
}
fn action_assignment_s65(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::Assignment1P1, 2usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::Assignment1P1, 2usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::Assignment1P1, 2usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::Assignment1P1, 2usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::Assignment1P1, 2usize)]),
        TK::Name => Vec::from(&[Reduce(PK::Assignment1P1, 2usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::Assignment1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_zeroormore_s66(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMore, 1usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMore, 1usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMore, 1usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMore, 1usize)]),
        TK::OSBracket => Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMore, 1usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMore, 1usize)]),
        TK::Name => Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMore, 1usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMore, 1usize)]),
        _ => vec![],
    }
}
fn action_zeroormoregreedy_s67(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMoreGreedy, 1usize)])
        }
        TK::OBrace => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMoreGreedy, 1usize)])
        }
        TK::OBracket => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMoreGreedy, 1usize)])
        }
        TK::CBracket => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMoreGreedy, 1usize)])
        }
        TK::OSBracket => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMoreGreedy, 1usize)])
        }
        TK::Choice => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMoreGreedy, 1usize)])
        }
        TK::Name => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMoreGreedy, 1usize)])
        }
        TK::StrConst => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpZeroOrMoreGreedy, 1usize)])
        }
        _ => vec![],
    }
}
fn action_oneormore_s68(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMore, 1usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMore, 1usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMore, 1usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMore, 1usize)]),
        TK::OSBracket => Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMore, 1usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMore, 1usize)]),
        TK::Name => Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMore, 1usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMore, 1usize)]),
        _ => vec![],
    }
}
fn action_oneormoregreedy_s69(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMoreGreedy, 1usize)])
        }
        TK::OBrace => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMoreGreedy, 1usize)])
        }
        TK::OBracket => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMoreGreedy, 1usize)])
        }
        TK::CBracket => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMoreGreedy, 1usize)])
        }
        TK::OSBracket => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMoreGreedy, 1usize)])
        }
        TK::Choice => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMoreGreedy, 1usize)])
        }
        TK::Name => Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMoreGreedy, 1usize)]),
        TK::StrConst => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpOneOrMoreGreedy, 1usize)])
        }
        _ => vec![],
    }
}
fn action_optional_s70(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::RepetitionOperatorOpOptional, 1usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::RepetitionOperatorOpOptional, 1usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::RepetitionOperatorOpOptional, 1usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::RepetitionOperatorOpOptional, 1usize)]),
        TK::OSBracket => Vec::from(&[Reduce(PK::RepetitionOperatorOpOptional, 1usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::RepetitionOperatorOpOptional, 1usize)]),
        TK::Name => Vec::from(&[Reduce(PK::RepetitionOperatorOpOptional, 1usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::RepetitionOperatorOpOptional, 1usize)]),
        _ => vec![],
    }
}
fn action_optionalgreedy_s71(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpOptionalGreedy, 1usize)])
        }
        TK::OBrace => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpOptionalGreedy, 1usize)])
        }
        TK::OBracket => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpOptionalGreedy, 1usize)])
        }
        TK::CBracket => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpOptionalGreedy, 1usize)])
        }
        TK::OSBracket => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpOptionalGreedy, 1usize)])
        }
        TK::Choice => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpOptionalGreedy, 1usize)])
        }
        TK::Name => Vec::from(&[Reduce(PK::RepetitionOperatorOpOptionalGreedy, 1usize)]),
        TK::StrConst => {
            Vec::from(&[Reduce(PK::RepetitionOperatorOpOptionalGreedy, 1usize)])
        }
        _ => vec![],
    }
}
fn action_repetitionoperatoropt_s72(
    token_kind: TokenKind,
) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::GrammarSymbolRefP2, 2usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::GrammarSymbolRefP2, 2usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::GrammarSymbolRefP2, 2usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::GrammarSymbolRefP2, 2usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::GrammarSymbolRefP2, 2usize)]),
        TK::Name => Vec::from(&[Reduce(PK::GrammarSymbolRefP2, 2usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::GrammarSymbolRefP2, 2usize)]),
        _ => vec![],
    }
}
fn action_repetitionoperator_s73(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::RepetitionOperatorOptP1, 1usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::RepetitionOperatorOptP1, 1usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::RepetitionOperatorOptP1, 1usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::RepetitionOperatorOptP1, 1usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::RepetitionOperatorOptP1, 1usize)]),
        TK::Name => Vec::from(&[Reduce(PK::RepetitionOperatorOptP1, 1usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::RepetitionOperatorOptP1, 1usize)]),
        _ => vec![],
    }
}
fn action_repetitionoperatorop_s74(
    token_kind: TokenKind,
) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::RepetitionModifiersOptP2, 0usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::RepetitionModifiersOptP2, 0usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::RepetitionModifiersOptP2, 0usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::RepetitionModifiersOptP2, 0usize)]),
        TK::OSBracket => Vec::from(&[Shift(State::OSBracketS100)]),
        TK::Choice => Vec::from(&[Reduce(PK::RepetitionModifiersOptP2, 0usize)]),
        TK::Name => Vec::from(&[Reduce(PK::RepetitionModifiersOptP2, 0usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::RepetitionModifiersOptP2, 0usize)]),
        _ => vec![],
    }
}
fn action_repetitionoperatoropt_s75(
    token_kind: TokenKind,
) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::GrammarSymbolRefP1, 2usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::GrammarSymbolRefP1, 2usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::GrammarSymbolRefP1, 2usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::GrammarSymbolRefP1, 2usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::GrammarSymbolRefP1, 2usize)]),
        TK::Name => Vec::from(&[Reduce(PK::GrammarSymbolRefP1, 2usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::GrammarSymbolRefP1, 2usize)]),
        _ => vec![],
    }
}
fn action_colon_s76(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IntConst => Vec::from(&[Shift(State::IntConstS103)]),
        TK::FloatConst => Vec::from(&[Shift(State::FloatConstS104)]),
        TK::BoolConst => Vec::from(&[Shift(State::BoolConstS105)]),
        TK::StrConst => Vec::from(&[Shift(State::StrConstS106)]),
        _ => vec![],
    }
}
fn action_comma_s77(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Left => Vec::from(&[Shift(State::LeftS41)]),
        TK::Right => Vec::from(&[Shift(State::RightS42)]),
        TK::Reduce => Vec::from(&[Shift(State::ReduceS43)]),
        TK::Shift => Vec::from(&[Shift(State::ShiftS44)]),
        TK::Dynamic => Vec::from(&[Shift(State::DynamicS45)]),
        TK::NOPS => Vec::from(&[Shift(State::NOPSS46)]),
        TK::NOPSE => Vec::from(&[Shift(State::NOPSES47)]),
        TK::Name => Vec::from(&[Shift(State::NameS48)]),
        TK::IntConst => Vec::from(&[Shift(State::IntConstS49)]),
        _ => vec![],
    }
}
fn action_cbrace_s78(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Colon => Vec::from(&[Shift(State::ColonS109)]),
        _ => vec![],
    }
}
fn action_left_s79(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::TermMetaDataLeft, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::TermMetaDataLeft, 1usize)]),
        _ => vec![],
    }
}
fn action_right_s80(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::TermMetaDataRight, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::TermMetaDataRight, 1usize)]),
        _ => vec![],
    }
}
fn action_reduce_s81(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::TermMetaDataReduce, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::TermMetaDataReduce, 1usize)]),
        _ => vec![],
    }
}
fn action_shift_s82(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::TermMetaDataShift, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::TermMetaDataShift, 1usize)]),
        _ => vec![],
    }
}
fn action_dynamic_s83(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::TermMetaDataDynamic, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::TermMetaDataDynamic, 1usize)]),
        _ => vec![],
    }
}
fn action_prefer_s84(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::TermMetaDataPrefer, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::TermMetaDataPrefer, 1usize)]),
        _ => vec![],
    }
}
fn action_finish_s85(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::TermMetaDataFinish, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::TermMetaDataFinish, 1usize)]),
        _ => vec![],
    }
}
fn action_nofinish_s86(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::TermMetaDataNoFinish, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::TermMetaDataNoFinish, 1usize)]),
        _ => vec![],
    }
}
fn action_name_s87(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Colon => Vec::from(&[Shift(State::ColonS76)]),
        _ => vec![],
    }
}
fn action_intconst_s88(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::TermMetaDataPriority, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::TermMetaDataPriority, 1usize)]),
        _ => vec![],
    }
}
fn action_termmetadata_s89(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::TermMetaDatasP2, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::TermMetaDatasP2, 1usize)]),
        _ => vec![],
    }
}
fn action_termmetadatas_s90(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Shift(State::CommaS110)]),
        TK::CBrace => Vec::from(&[Shift(State::CBraceS111)]),
        _ => vec![],
    }
}
fn action_usermetadata_s91(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::TermMetaDataP10, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::TermMetaDataP10, 1usize)]),
        _ => vec![],
    }
}
fn action_semicolon_s92(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::TerminalRuleP1, 5usize)]),
        TK::Name => Vec::from(&[Reduce(PK::TerminalRuleP1, 5usize)]),
        TK::Annotation => Vec::from(&[Reduce(PK::TerminalRuleP1, 5usize)]),
        _ => vec![],
    }
}
fn action_obrace_s93(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Left => Vec::from(&[Shift(State::LeftS79)]),
        TK::Right => Vec::from(&[Shift(State::RightS80)]),
        TK::Reduce => Vec::from(&[Shift(State::ReduceS81)]),
        TK::Shift => Vec::from(&[Shift(State::ShiftS82)]),
        TK::Dynamic => Vec::from(&[Shift(State::DynamicS83)]),
        TK::Prefer => Vec::from(&[Shift(State::PreferS84)]),
        TK::Finish => Vec::from(&[Shift(State::FinishS85)]),
        TK::NoFinish => Vec::from(&[Shift(State::NoFinishS86)]),
        TK::Name => Vec::from(&[Shift(State::NameS87)]),
        TK::IntConst => Vec::from(&[Shift(State::IntConstS88)]),
        _ => vec![],
    }
}
fn action_cbracket_s94(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::ProductionGroupP1, 3usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::ProductionGroupP1, 3usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::ProductionGroupP1, 3usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::ProductionGroupP1, 3usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::ProductionGroupP1, 3usize)]),
        TK::ZeroOrMore => Vec::from(&[Reduce(PK::ProductionGroupP1, 3usize)]),
        TK::ZeroOrMoreGreedy => Vec::from(&[Reduce(PK::ProductionGroupP1, 3usize)]),
        TK::OneOrMore => Vec::from(&[Reduce(PK::ProductionGroupP1, 3usize)]),
        TK::OneOrMoreGreedy => Vec::from(&[Reduce(PK::ProductionGroupP1, 3usize)]),
        TK::Optional => Vec::from(&[Reduce(PK::ProductionGroupP1, 3usize)]),
        TK::OptionalGreedy => Vec::from(&[Reduce(PK::ProductionGroupP1, 3usize)]),
        TK::Name => Vec::from(&[Reduce(PK::ProductionGroupP1, 3usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::ProductionGroupP1, 3usize)]),
        _ => vec![],
    }
}
fn action_name_s95(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::ZeroOrMore => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::ZeroOrMoreGreedy => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::OneOrMore => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::OneOrMoreGreedy => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::Optional => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::OptionalGreedy => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::Name => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::GrammarSymbolP1, 1usize)]),
        _ => vec![],
    }
}
fn action_grammarsymbolref_s96(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::PlainAssignmentP1, 3usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::PlainAssignmentP1, 3usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::PlainAssignmentP1, 3usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::PlainAssignmentP1, 3usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::PlainAssignmentP1, 3usize)]),
        TK::Name => Vec::from(&[Reduce(PK::PlainAssignmentP1, 3usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::PlainAssignmentP1, 3usize)]),
        _ => vec![],
    }
}
fn action_grammarsymbolref_s97(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::BoolAssignmentP1, 3usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::BoolAssignmentP1, 3usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::BoolAssignmentP1, 3usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::BoolAssignmentP1, 3usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::BoolAssignmentP1, 3usize)]),
        TK::Name => Vec::from(&[Reduce(PK::BoolAssignmentP1, 3usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::BoolAssignmentP1, 3usize)]),
        _ => vec![],
    }
}
fn action_production_s98(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::GrammarRuleRHSP1, 3usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::GrammarRuleRHSP1, 3usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::GrammarRuleRHSP1, 3usize)]),
        _ => vec![],
    }
}
fn action_prodmetadatas_s99(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Shift(State::CommaS77)]),
        TK::CBrace => Vec::from(&[Shift(State::CBraceS113)]),
        _ => vec![],
    }
}
fn action_osbracket_s100(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Name => Vec::from(&[Shift(State::NameS114)]),
        _ => vec![],
    }
}
fn action_repetitionmodifiersopt_s101(
    token_kind: TokenKind,
) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::RepetitionOperatorP1, 2usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::RepetitionOperatorP1, 2usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::RepetitionOperatorP1, 2usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::RepetitionOperatorP1, 2usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::RepetitionOperatorP1, 2usize)]),
        TK::Name => Vec::from(&[Reduce(PK::RepetitionOperatorP1, 2usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::RepetitionOperatorP1, 2usize)]),
        _ => vec![],
    }
}
fn action_repetitionmodifiers_s102(
    token_kind: TokenKind,
) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::RepetitionModifiersOptP1, 1usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::RepetitionModifiersOptP1, 1usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::RepetitionModifiersOptP1, 1usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::RepetitionModifiersOptP1, 1usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::RepetitionModifiersOptP1, 1usize)]),
        TK::Name => Vec::from(&[Reduce(PK::RepetitionModifiersOptP1, 1usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::RepetitionModifiersOptP1, 1usize)]),
        _ => vec![],
    }
}
fn action_intconst_s103(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ConstValP1, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ConstValP1, 1usize)]),
        _ => vec![],
    }
}
fn action_floatconst_s104(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ConstValP2, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ConstValP2, 1usize)]),
        _ => vec![],
    }
}
fn action_boolconst_s105(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ConstValP3, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ConstValP3, 1usize)]),
        _ => vec![],
    }
}
fn action_strconst_s106(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ConstValP4, 1usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ConstValP4, 1usize)]),
        _ => vec![],
    }
}
fn action_constval_s107(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::UserMetaDataP1, 3usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::UserMetaDataP1, 3usize)]),
        _ => vec![],
    }
}
fn action_prodmetadata_s108(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::ProdMetaDatasP1, 3usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::ProdMetaDatasP1, 3usize)]),
        _ => vec![],
    }
}
fn action_colon_s109(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OBracket => Vec::from(&[Shift(State::OBracketS29)]),
        TK::Name => Vec::from(&[Shift(State::NameS30)]),
        TK::StrConst => Vec::from(&[Shift(State::StrConstS31)]),
        _ => vec![],
    }
}
fn action_comma_s110(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Left => Vec::from(&[Shift(State::LeftS79)]),
        TK::Right => Vec::from(&[Shift(State::RightS80)]),
        TK::Reduce => Vec::from(&[Shift(State::ReduceS81)]),
        TK::Shift => Vec::from(&[Shift(State::ShiftS82)]),
        TK::Dynamic => Vec::from(&[Shift(State::DynamicS83)]),
        TK::Prefer => Vec::from(&[Shift(State::PreferS84)]),
        TK::Finish => Vec::from(&[Shift(State::FinishS85)]),
        TK::NoFinish => Vec::from(&[Shift(State::NoFinishS86)]),
        TK::Name => Vec::from(&[Shift(State::NameS87)]),
        TK::IntConst => Vec::from(&[Shift(State::IntConstS88)]),
        _ => vec![],
    }
}
fn action_cbrace_s111(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Shift(State::SemiColonS119)]),
        _ => vec![],
    }
}
fn action_termmetadatas_s112(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Shift(State::CommaS110)]),
        TK::CBrace => Vec::from(&[Shift(State::CBraceS120)]),
        _ => vec![],
    }
}
fn action_cbrace_s113(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::ProductionP2, 4usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::ProductionP2, 4usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::ProductionP2, 4usize)]),
        _ => vec![],
    }
}
fn action_name_s114(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::RepetitionModifierP1, 1usize)]),
        TK::CSBracket => Vec::from(&[Reduce(PK::RepetitionModifierP1, 1usize)]),
        _ => vec![],
    }
}
fn action_repetitionmodifier1_s115(
    token_kind: TokenKind,
) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Shift(State::CommaS121)]),
        TK::CSBracket => Vec::from(&[Shift(State::CSBracketS122)]),
        _ => vec![],
    }
}
fn action_repetitionmodifier_s116(
    token_kind: TokenKind,
) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::RepetitionModifier1P2, 1usize)]),
        TK::CSBracket => Vec::from(&[Reduce(PK::RepetitionModifier1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_grammarrulerhs_s117(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Shift(State::SemiColonS123)]),
        TK::Choice => Vec::from(&[Shift(State::ChoiceS63)]),
        _ => vec![],
    }
}
fn action_termmetadata_s118(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::TermMetaDatasP1, 3usize)]),
        TK::CBrace => Vec::from(&[Reduce(PK::TermMetaDatasP1, 3usize)]),
        _ => vec![],
    }
}
fn action_semicolon_s119(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::TerminalRuleP4, 7usize)]),
        TK::Name => Vec::from(&[Reduce(PK::TerminalRuleP4, 7usize)]),
        TK::Annotation => Vec::from(&[Reduce(PK::TerminalRuleP4, 7usize)]),
        _ => vec![],
    }
}
fn action_cbrace_s120(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Shift(State::SemiColonS124)]),
        _ => vec![],
    }
}
fn action_comma_s121(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Name => Vec::from(&[Shift(State::NameS114)]),
        _ => vec![],
    }
}
fn action_csbracket_s122(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::SemiColon => Vec::from(&[Reduce(PK::RepetitionModifiersP1, 3usize)]),
        TK::OBrace => Vec::from(&[Reduce(PK::RepetitionModifiersP1, 3usize)]),
        TK::OBracket => Vec::from(&[Reduce(PK::RepetitionModifiersP1, 3usize)]),
        TK::CBracket => Vec::from(&[Reduce(PK::RepetitionModifiersP1, 3usize)]),
        TK::Choice => Vec::from(&[Reduce(PK::RepetitionModifiersP1, 3usize)]),
        TK::Name => Vec::from(&[Reduce(PK::RepetitionModifiersP1, 3usize)]),
        TK::StrConst => Vec::from(&[Reduce(PK::RepetitionModifiersP1, 3usize)]),
        _ => vec![],
    }
}
fn action_semicolon_s123(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::GrammarRuleP2, 8usize)]),
        TK::Terminals => Vec::from(&[Reduce(PK::GrammarRuleP2, 8usize)]),
        TK::Name => Vec::from(&[Reduce(PK::GrammarRuleP2, 8usize)]),
        TK::Annotation => Vec::from(&[Reduce(PK::GrammarRuleP2, 8usize)]),
        _ => vec![],
    }
}
fn action_semicolon_s124(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::TerminalRuleP3, 8usize)]),
        TK::Name => Vec::from(&[Reduce(PK::TerminalRuleP3, 8usize)]),
        TK::Annotation => Vec::from(&[Reduce(PK::TerminalRuleP3, 8usize)]),
        _ => vec![],
    }
}
fn action_repetitionmodifier_s125(
    token_kind: TokenKind,
) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Comma => Vec::from(&[Reduce(PK::RepetitionModifier1P1, 3usize)]),
        TK::CSBracket => Vec::from(&[Reduce(PK::RepetitionModifier1P1, 3usize)]),
        _ => vec![],
    }
}
fn action_augl_s126(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::LayoutItem0P2, 0usize)]),
        TK::OComment => Vec::from(&[Shift(State::OCommentS127)]),
        TK::WS => Vec::from(&[Shift(State::WSS128)]),
        TK::CommentLine => Vec::from(&[Shift(State::CommentLineS129)]),
        _ => vec![],
    }
}
fn action_ocomment_s127(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OComment => Vec::from(&[Shift(State::OCommentS127)]),
        TK::CComment => Vec::from(&[Reduce(PK::Cornc0P2, 0usize)]),
        TK::WS => Vec::from(&[Shift(State::WSS135)]),
        TK::CommentLine => Vec::from(&[Shift(State::CommentLineS129)]),
        TK::NotComment => Vec::from(&[Shift(State::NotCommentS136)]),
        _ => vec![],
    }
}
fn action_ws_s128(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::LayoutItemP1, 1usize)]),
        TK::OComment => Vec::from(&[Reduce(PK::LayoutItemP1, 1usize)]),
        TK::WS => Vec::from(&[Reduce(PK::LayoutItemP1, 1usize)]),
        TK::CommentLine => Vec::from(&[Reduce(PK::LayoutItemP1, 1usize)]),
        _ => vec![],
    }
}
fn action_commentline_s129(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::CommentP2, 1usize)]),
        TK::OComment => Vec::from(&[Reduce(PK::CommentP2, 1usize)]),
        TK::CComment => Vec::from(&[Reduce(PK::CommentP2, 1usize)]),
        TK::WS => Vec::from(&[Reduce(PK::CommentP2, 1usize)]),
        TK::CommentLine => Vec::from(&[Reduce(PK::CommentP2, 1usize)]),
        TK::NotComment => Vec::from(&[Reduce(PK::CommentP2, 1usize)]),
        _ => vec![],
    }
}
fn action_layout_s130(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Accept]),
        _ => vec![],
    }
}
fn action_layoutitem1_s131(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::LayoutItem0P1, 1usize)]),
        TK::OComment => Vec::from(&[Shift(State::OCommentS127)]),
        TK::WS => Vec::from(&[Shift(State::WSS128)]),
        TK::CommentLine => Vec::from(&[Shift(State::CommentLineS129)]),
        _ => vec![],
    }
}
fn action_layoutitem0_s132(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::LayoutP1, 1usize)]),
        _ => vec![],
    }
}
fn action_layoutitem_s133(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::LayoutItem1P2, 1usize)]),
        TK::OComment => Vec::from(&[Reduce(PK::LayoutItem1P2, 1usize)]),
        TK::WS => Vec::from(&[Reduce(PK::LayoutItem1P2, 1usize)]),
        TK::CommentLine => Vec::from(&[Reduce(PK::LayoutItem1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_comment_s134(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::LayoutItemP2, 1usize)]),
        TK::OComment => Vec::from(&[Reduce(PK::LayoutItemP2, 1usize)]),
        TK::WS => Vec::from(&[Reduce(PK::LayoutItemP2, 1usize)]),
        TK::CommentLine => Vec::from(&[Reduce(PK::LayoutItemP2, 1usize)]),
        _ => vec![],
    }
}
fn action_ws_s135(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OComment => Vec::from(&[Reduce(PK::CorncP3, 1usize)]),
        TK::CComment => Vec::from(&[Reduce(PK::CorncP3, 1usize)]),
        TK::WS => Vec::from(&[Reduce(PK::CorncP3, 1usize)]),
        TK::CommentLine => Vec::from(&[Reduce(PK::CorncP3, 1usize)]),
        TK::NotComment => Vec::from(&[Reduce(PK::CorncP3, 1usize)]),
        _ => vec![],
    }
}
fn action_notcomment_s136(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OComment => Vec::from(&[Reduce(PK::CorncP2, 1usize)]),
        TK::CComment => Vec::from(&[Reduce(PK::CorncP2, 1usize)]),
        TK::WS => Vec::from(&[Reduce(PK::CorncP2, 1usize)]),
        TK::CommentLine => Vec::from(&[Reduce(PK::CorncP2, 1usize)]),
        TK::NotComment => Vec::from(&[Reduce(PK::CorncP2, 1usize)]),
        _ => vec![],
    }
}
fn action_comment_s137(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OComment => Vec::from(&[Reduce(PK::CorncP1, 1usize)]),
        TK::CComment => Vec::from(&[Reduce(PK::CorncP1, 1usize)]),
        TK::WS => Vec::from(&[Reduce(PK::CorncP1, 1usize)]),
        TK::CommentLine => Vec::from(&[Reduce(PK::CorncP1, 1usize)]),
        TK::NotComment => Vec::from(&[Reduce(PK::CorncP1, 1usize)]),
        _ => vec![],
    }
}
fn action_corncs_s138(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CComment => Vec::from(&[Shift(State::CCommentS143)]),
        _ => vec![],
    }
}
fn action_cornc1_s139(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OComment => Vec::from(&[Shift(State::OCommentS127)]),
        TK::CComment => Vec::from(&[Reduce(PK::Cornc0P1, 1usize)]),
        TK::WS => Vec::from(&[Shift(State::WSS135)]),
        TK::CommentLine => Vec::from(&[Shift(State::CommentLineS129)]),
        TK::NotComment => Vec::from(&[Shift(State::NotCommentS136)]),
        _ => vec![],
    }
}
fn action_cornc0_s140(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CComment => Vec::from(&[Reduce(PK::CorncsP1, 1usize)]),
        _ => vec![],
    }
}
fn action_cornc_s141(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OComment => Vec::from(&[Reduce(PK::Cornc1P2, 1usize)]),
        TK::CComment => Vec::from(&[Reduce(PK::Cornc1P2, 1usize)]),
        TK::WS => Vec::from(&[Reduce(PK::Cornc1P2, 1usize)]),
        TK::CommentLine => Vec::from(&[Reduce(PK::Cornc1P2, 1usize)]),
        TK::NotComment => Vec::from(&[Reduce(PK::Cornc1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_layoutitem_s142(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::LayoutItem1P1, 2usize)]),
        TK::OComment => Vec::from(&[Reduce(PK::LayoutItem1P1, 2usize)]),
        TK::WS => Vec::from(&[Reduce(PK::LayoutItem1P1, 2usize)]),
        TK::CommentLine => Vec::from(&[Reduce(PK::LayoutItem1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_ccomment_s143(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::CommentP1, 3usize)]),
        TK::OComment => Vec::from(&[Reduce(PK::CommentP1, 3usize)]),
        TK::CComment => Vec::from(&[Reduce(PK::CommentP1, 3usize)]),
        TK::WS => Vec::from(&[Reduce(PK::CommentP1, 3usize)]),
        TK::CommentLine => Vec::from(&[Reduce(PK::CommentP1, 3usize)]),
        TK::NotComment => Vec::from(&[Reduce(PK::CommentP1, 3usize)]),
        _ => vec![],
    }
}
fn action_cornc_s144(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OComment => Vec::from(&[Reduce(PK::Cornc1P1, 2usize)]),
        TK::CComment => Vec::from(&[Reduce(PK::Cornc1P1, 2usize)]),
        TK::WS => Vec::from(&[Reduce(PK::Cornc1P1, 2usize)]),
        TK::CommentLine => Vec::from(&[Reduce(PK::Cornc1P1, 2usize)]),
        TK::NotComment => Vec::from(&[Reduce(PK::Cornc1P1, 2usize)]),
        _ => vec![],
    }
}
fn goto_aug_s0(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::File => State::FileS4,
        NonTermKind::GrammarRule1 => State::GrammarRule1S5,
        NonTermKind::ImportStm1 => State::ImportStm1S6,
        NonTermKind::ImportStm => State::ImportStmS7,
        NonTermKind::GrammarRule => State::GrammarRuleS8,
        NonTermKind::AnnotationOpt => State::AnnotationOptS9,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::AUGS0
            )
        }
    }
}
fn goto_terminals_s1(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::TerminalRule1 => State::TerminalRule1S10,
        NonTermKind::AnnotationOpt => State::AnnotationOptS11,
        NonTermKind::TerminalRule => State::TerminalRuleS12,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::TerminalsS1
            )
        }
    }
}
fn goto_grammarrule1_s5(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::GrammarRule => State::GrammarRuleS15,
        NonTermKind::AnnotationOpt => State::AnnotationOptS9,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::GrammarRule1S5
            )
        }
    }
}
fn goto_importstm1_s6(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::GrammarRule1 => State::GrammarRule1S16,
        NonTermKind::ImportStm => State::ImportStmS17,
        NonTermKind::GrammarRule => State::GrammarRuleS8,
        NonTermKind::AnnotationOpt => State::AnnotationOptS9,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::ImportStm1S6
            )
        }
    }
}
fn goto_terminalrule1_s10(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::AnnotationOpt => State::AnnotationOptS11,
        NonTermKind::TerminalRule => State::TerminalRuleS19,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::TerminalRule1S10
            )
        }
    }
}
fn goto_terminals_s14(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::TerminalRule1 => State::TerminalRule1S22,
        NonTermKind::AnnotationOpt => State::AnnotationOptS11,
        NonTermKind::TerminalRule => State::TerminalRuleS12,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::TerminalsS14
            )
        }
    }
}
fn goto_grammarrule1_s16(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::GrammarRule => State::GrammarRuleS15,
        NonTermKind::AnnotationOpt => State::AnnotationOptS9,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::GrammarRule1S16
            )
        }
    }
}
fn goto_terminalrule1_s22(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::AnnotationOpt => State::AnnotationOptS11,
        NonTermKind::TerminalRule => State::TerminalRuleS19,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::TerminalRule1S22
            )
        }
    }
}
fn goto_terminals_s23(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::TerminalRule1 => State::TerminalRule1S28,
        NonTermKind::AnnotationOpt => State::AnnotationOptS11,
        NonTermKind::TerminalRule => State::TerminalRuleS12,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::TerminalsS23
            )
        }
    }
}
fn goto_colon_s24(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::GrammarRuleRHS => State::GrammarRuleRHSS32,
        NonTermKind::Production => State::ProductionS33,
        NonTermKind::Assignment1 => State::Assignment1S34,
        NonTermKind::Assignment => State::AssignmentS35,
        NonTermKind::PlainAssignment => State::PlainAssignmentS36,
        NonTermKind::BoolAssignment => State::BoolAssignmentS37,
        NonTermKind::ProductionGroup => State::ProductionGroupS38,
        NonTermKind::GrammarSymbolRef => State::GrammarSymbolRefS39,
        NonTermKind::GrammarSymbol => State::GrammarSymbolS40,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::ColonS24
            )
        }
    }
}
fn goto_obrace_s25(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::ProdMetaData => State::ProdMetaDataS50,
        NonTermKind::ProdMetaDatas => State::ProdMetaDatasS51,
        NonTermKind::UserMetaData => State::UserMetaDataS52,
        NonTermKind::ProdKind => State::ProdKindS53,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OBraceS25
            )
        }
    }
}
fn goto_colon_s26(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Recognizer => State::RecognizerS58,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::ColonS26
            )
        }
    }
}
fn goto_terminalrule1_s28(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::AnnotationOpt => State::AnnotationOptS11,
        NonTermKind::TerminalRule => State::TerminalRuleS19,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::TerminalRule1S28
            )
        }
    }
}
fn goto_obracket_s29(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::GrammarRuleRHS => State::GrammarRuleRHSS59,
        NonTermKind::Production => State::ProductionS33,
        NonTermKind::Assignment1 => State::Assignment1S34,
        NonTermKind::Assignment => State::AssignmentS35,
        NonTermKind::PlainAssignment => State::PlainAssignmentS36,
        NonTermKind::BoolAssignment => State::BoolAssignmentS37,
        NonTermKind::ProductionGroup => State::ProductionGroupS38,
        NonTermKind::GrammarSymbolRef => State::GrammarSymbolRefS39,
        NonTermKind::GrammarSymbol => State::GrammarSymbolS40,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OBracketS29
            )
        }
    }
}
fn goto_assignment1_s34(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Assignment => State::AssignmentS65,
        NonTermKind::PlainAssignment => State::PlainAssignmentS36,
        NonTermKind::BoolAssignment => State::BoolAssignmentS37,
        NonTermKind::ProductionGroup => State::ProductionGroupS38,
        NonTermKind::GrammarSymbolRef => State::GrammarSymbolRefS39,
        NonTermKind::GrammarSymbol => State::GrammarSymbolS40,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Assignment1S34
            )
        }
    }
}
fn goto_productiongroup_s38(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::RepetitionOperatorOpt => State::RepetitionOperatorOptS72,
        NonTermKind::RepetitionOperator => State::RepetitionOperatorS73,
        NonTermKind::RepetitionOperatorOp => State::RepetitionOperatorOpS74,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::ProductionGroupS38
            )
        }
    }
}
fn goto_grammarsymbol_s40(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::RepetitionOperatorOpt => State::RepetitionOperatorOptS75,
        NonTermKind::RepetitionOperator => State::RepetitionOperatorS73,
        NonTermKind::RepetitionOperatorOp => State::RepetitionOperatorOpS74,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::GrammarSymbolS40
            )
        }
    }
}
fn goto_obrace_s55(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::TermMetaData => State::TermMetaDataS89,
        NonTermKind::TermMetaDatas => State::TermMetaDatasS90,
        NonTermKind::UserMetaData => State::UserMetaDataS91,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OBraceS55
            )
        }
    }
}
fn goto_equals_s60(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::ProductionGroup => State::ProductionGroupS38,
        NonTermKind::GrammarSymbolRef => State::GrammarSymbolRefS96,
        NonTermKind::GrammarSymbol => State::GrammarSymbolS40,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::EqualsS60
            )
        }
    }
}
fn goto_qequals_s61(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::ProductionGroup => State::ProductionGroupS38,
        NonTermKind::GrammarSymbolRef => State::GrammarSymbolRefS97,
        NonTermKind::GrammarSymbol => State::GrammarSymbolS40,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::QEqualsS61
            )
        }
    }
}
fn goto_choice_s63(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Production => State::ProductionS98,
        NonTermKind::Assignment1 => State::Assignment1S34,
        NonTermKind::Assignment => State::AssignmentS35,
        NonTermKind::PlainAssignment => State::PlainAssignmentS36,
        NonTermKind::BoolAssignment => State::BoolAssignmentS37,
        NonTermKind::ProductionGroup => State::ProductionGroupS38,
        NonTermKind::GrammarSymbolRef => State::GrammarSymbolRefS39,
        NonTermKind::GrammarSymbol => State::GrammarSymbolS40,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::ChoiceS63
            )
        }
    }
}
fn goto_obrace_s64(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::ProdMetaData => State::ProdMetaDataS50,
        NonTermKind::ProdMetaDatas => State::ProdMetaDatasS99,
        NonTermKind::UserMetaData => State::UserMetaDataS52,
        NonTermKind::ProdKind => State::ProdKindS53,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OBraceS64
            )
        }
    }
}
fn goto_repetitionoperatorop_s74(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::RepetitionModifiersOpt => State::RepetitionModifiersOptS101,
        NonTermKind::RepetitionModifiers => State::RepetitionModifiersS102,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::RepetitionOperatorOpS74
            )
        }
    }
}
fn goto_colon_s76(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::ConstVal => State::ConstValS107,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::ColonS76
            )
        }
    }
}
fn goto_comma_s77(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::ProdMetaData => State::ProdMetaDataS108,
        NonTermKind::UserMetaData => State::UserMetaDataS52,
        NonTermKind::ProdKind => State::ProdKindS53,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::CommaS77
            )
        }
    }
}
fn goto_obrace_s93(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::TermMetaData => State::TermMetaDataS89,
        NonTermKind::TermMetaDatas => State::TermMetaDatasS112,
        NonTermKind::UserMetaData => State::UserMetaDataS91,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OBraceS93
            )
        }
    }
}
fn goto_osbracket_s100(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::RepetitionModifier1 => State::RepetitionModifier1S115,
        NonTermKind::RepetitionModifier => State::RepetitionModifierS116,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OSBracketS100
            )
        }
    }
}
fn goto_colon_s109(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::GrammarRuleRHS => State::GrammarRuleRHSS117,
        NonTermKind::Production => State::ProductionS33,
        NonTermKind::Assignment1 => State::Assignment1S34,
        NonTermKind::Assignment => State::AssignmentS35,
        NonTermKind::PlainAssignment => State::PlainAssignmentS36,
        NonTermKind::BoolAssignment => State::BoolAssignmentS37,
        NonTermKind::ProductionGroup => State::ProductionGroupS38,
        NonTermKind::GrammarSymbolRef => State::GrammarSymbolRefS39,
        NonTermKind::GrammarSymbol => State::GrammarSymbolS40,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::ColonS109
            )
        }
    }
}
fn goto_comma_s110(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::TermMetaData => State::TermMetaDataS118,
        NonTermKind::UserMetaData => State::UserMetaDataS91,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::CommaS110
            )
        }
    }
}
fn goto_comma_s121(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::RepetitionModifier => State::RepetitionModifierS125,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::CommaS121
            )
        }
    }
}
fn goto_augl_s126(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Layout => State::LayoutS130,
        NonTermKind::LayoutItem1 => State::LayoutItem1S131,
        NonTermKind::LayoutItem0 => State::LayoutItem0S132,
        NonTermKind::LayoutItem => State::LayoutItemS133,
        NonTermKind::Comment => State::CommentS134,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::AUGLS126
            )
        }
    }
}
fn goto_ocomment_s127(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Comment => State::CommentS137,
        NonTermKind::Corncs => State::CorncsS138,
        NonTermKind::Cornc1 => State::Cornc1S139,
        NonTermKind::Cornc0 => State::Cornc0S140,
        NonTermKind::Cornc => State::CorncS141,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OCommentS127
            )
        }
    }
}
fn goto_layoutitem1_s131(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::LayoutItem => State::LayoutItemS142,
        NonTermKind::Comment => State::CommentS134,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::LayoutItem1S131
            )
        }
    }
}
fn goto_cornc1_s139(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Comment => State::CommentS137,
        NonTermKind::Cornc => State::CorncS144,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Cornc1S139
            )
        }
    }
}
fn goto_invalid(_nonterm_kind: NonTermKind) -> State {
    panic!("Invalid GOTO entry!");
}
pub(crate) static PARSER_DEFINITION: RustemoParserDefinition = RustemoParserDefinition {
    actions: [
        action_aug_s0,
        action_terminals_s1,
        action_import_s2,
        action_annotation_s3,
        action_file_s4,
        action_grammarrule1_s5,
        action_importstm1_s6,
        action_importstm_s7,
        action_grammarrule_s8,
        action_annotationopt_s9,
        action_terminalrule1_s10,
        action_annotationopt_s11,
        action_terminalrule_s12,
        action_strconst_s13,
        action_terminals_s14,
        action_grammarrule_s15,
        action_grammarrule1_s16,
        action_importstm_s17,
        action_name_s18,
        action_terminalrule_s19,
        action_name_s20,
        action_as_s21,
        action_terminalrule1_s22,
        action_terminals_s23,
        action_colon_s24,
        action_obrace_s25,
        action_colon_s26,
        action_name_s27,
        action_terminalrule1_s28,
        action_obracket_s29,
        action_name_s30,
        action_strconst_s31,
        action_grammarrulerhs_s32,
        action_production_s33,
        action_assignment1_s34,
        action_assignment_s35,
        action_plainassignment_s36,
        action_boolassignment_s37,
        action_productiongroup_s38,
        action_grammarsymbolref_s39,
        action_grammarsymbol_s40,
        action_left_s41,
        action_right_s42,
        action_reduce_s43,
        action_shift_s44,
        action_dynamic_s45,
        action_nops_s46,
        action_nopse_s47,
        action_name_s48,
        action_intconst_s49,
        action_prodmetadata_s50,
        action_prodmetadatas_s51,
        action_usermetadata_s52,
        action_prodkind_s53,
        action_semicolon_s54,
        action_obrace_s55,
        action_regexterm_s56,
        action_strconst_s57,
        action_recognizer_s58,
        action_grammarrulerhs_s59,
        action_equals_s60,
        action_qequals_s61,
        action_semicolon_s62,
        action_choice_s63,
        action_obrace_s64,
        action_assignment_s65,
        action_zeroormore_s66,
        action_zeroormoregreedy_s67,
        action_oneormore_s68,
        action_oneormoregreedy_s69,
        action_optional_s70,
        action_optionalgreedy_s71,
        action_repetitionoperatoropt_s72,
        action_repetitionoperator_s73,
        action_repetitionoperatorop_s74,
        action_repetitionoperatoropt_s75,
        action_colon_s76,
        action_comma_s77,
        action_cbrace_s78,
        action_left_s79,
        action_right_s80,
        action_reduce_s81,
        action_shift_s82,
        action_dynamic_s83,
        action_prefer_s84,
        action_finish_s85,
        action_nofinish_s86,
        action_name_s87,
        action_intconst_s88,
        action_termmetadata_s89,
        action_termmetadatas_s90,
        action_usermetadata_s91,
        action_semicolon_s92,
        action_obrace_s93,
        action_cbracket_s94,
        action_name_s95,
        action_grammarsymbolref_s96,
        action_grammarsymbolref_s97,
        action_production_s98,
        action_prodmetadatas_s99,
        action_osbracket_s100,
        action_repetitionmodifiersopt_s101,
        action_repetitionmodifiers_s102,
        action_intconst_s103,
        action_floatconst_s104,
        action_boolconst_s105,
        action_strconst_s106,
        action_constval_s107,
        action_prodmetadata_s108,
        action_colon_s109,
        action_comma_s110,
        action_cbrace_s111,
        action_termmetadatas_s112,
        action_cbrace_s113,
        action_name_s114,
        action_repetitionmodifier1_s115,
        action_repetitionmodifier_s116,
        action_grammarrulerhs_s117,
        action_termmetadata_s118,
        action_semicolon_s119,
        action_cbrace_s120,
        action_comma_s121,
        action_csbracket_s122,
        action_semicolon_s123,
        action_semicolon_s124,
        action_repetitionmodifier_s125,
        action_augl_s126,
        action_ocomment_s127,
        action_ws_s128,
        action_commentline_s129,
        action_layout_s130,
        action_layoutitem1_s131,
        action_layoutitem0_s132,
        action_layoutitem_s133,
        action_comment_s134,
        action_ws_s135,
        action_notcomment_s136,
        action_comment_s137,
        action_corncs_s138,
        action_cornc1_s139,
        action_cornc0_s140,
        action_cornc_s141,
        action_layoutitem_s142,
        action_ccomment_s143,
        action_cornc_s144,
    ],
    gotos: [
        goto_aug_s0,
        goto_terminals_s1,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_grammarrule1_s5,
        goto_importstm1_s6,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_terminalrule1_s10,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_terminals_s14,
        goto_invalid,
        goto_grammarrule1_s16,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_terminalrule1_s22,
        goto_terminals_s23,
        goto_colon_s24,
        goto_obrace_s25,
        goto_colon_s26,
        goto_invalid,
        goto_terminalrule1_s28,
        goto_obracket_s29,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_assignment1_s34,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_productiongroup_s38,
        goto_invalid,
        goto_grammarsymbol_s40,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_obrace_s55,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_equals_s60,
        goto_qequals_s61,
        goto_invalid,
        goto_choice_s63,
        goto_obrace_s64,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_repetitionoperatorop_s74,
        goto_invalid,
        goto_colon_s76,
        goto_comma_s77,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_obrace_s93,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_osbracket_s100,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_colon_s109,
        goto_comma_s110,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_comma_s121,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_augl_s126,
        goto_ocomment_s127,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_layoutitem1_s131,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_cornc1_s139,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
    ],
    token_kinds: [
        [
            Some((TK::Terminals, true)),
            Some((TK::Import, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Name, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Terminals, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Import, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Import, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Terminals, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Name, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Name, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Import, true)),
            Some((TK::As, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Terminals, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Terminals, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Import, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Colon, true)),
            Some((TK::OBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Colon, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Name, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OBracket, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Dynamic, true)),
            Some((TK::Reduce, true)),
            Some((TK::Right, true)),
            Some((TK::Shift, true)),
            Some((TK::NOPSE, true)),
            Some((TK::Left, true)),
            Some((TK::NOPS, true)),
            Some((TK::Name, false)),
            Some((TK::IntConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::RegexTerm, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Import, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OBracket, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::ZeroOrMoreGreedy, true)),
            Some((TK::OneOrMoreGreedy, true)),
            Some((TK::OptionalGreedy, true)),
            Some((TK::QEquals, true)),
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::ZeroOrMore, true)),
            Some((TK::OneOrMore, true)),
            Some((TK::Optional, true)),
            Some((TK::Equals, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
        ],
        [
            Some((TK::ZeroOrMoreGreedy, true)),
            Some((TK::OneOrMoreGreedy, true)),
            Some((TK::OptionalGreedy, true)),
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::ZeroOrMore, true)),
            Some((TK::OneOrMore, true)),
            Some((TK::Optional, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::Choice, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::ZeroOrMoreGreedy, true)),
            Some((TK::OneOrMoreGreedy, true)),
            Some((TK::OptionalGreedy, true)),
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::ZeroOrMore, true)),
            Some((TK::OneOrMore, true)),
            Some((TK::Optional, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::ZeroOrMoreGreedy, true)),
            Some((TK::OneOrMoreGreedy, true)),
            Some((TK::OptionalGreedy, true)),
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::ZeroOrMore, true)),
            Some((TK::OneOrMore, true)),
            Some((TK::Optional, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Colon, true)),
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::NoFinish, true)),
            Some((TK::Dynamic, true)),
            Some((TK::Reduce, true)),
            Some((TK::Prefer, true)),
            Some((TK::Finish, true)),
            Some((TK::Right, true)),
            Some((TK::Shift, true)),
            Some((TK::Left, true)),
            Some((TK::Name, false)),
            Some((TK::IntConst, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OBracket, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OBracket, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Terminals, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OBracket, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Dynamic, true)),
            Some((TK::Reduce, true)),
            Some((TK::Right, true)),
            Some((TK::Shift, true)),
            Some((TK::NOPSE, true)),
            Some((TK::Left, true)),
            Some((TK::NOPS, true)),
            Some((TK::Name, false)),
            Some((TK::IntConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::OSBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::OSBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::OSBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::OSBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::OSBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::OSBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::OSBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::IntConst, false)),
            Some((TK::FloatConst, false)),
            Some((TK::BoolConst, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Dynamic, true)),
            Some((TK::Reduce, true)),
            Some((TK::Right, true)),
            Some((TK::Shift, true)),
            Some((TK::NOPSE, true)),
            Some((TK::Left, true)),
            Some((TK::NOPS, true)),
            Some((TK::Name, false)),
            Some((TK::IntConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Colon, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Colon, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::NoFinish, true)),
            Some((TK::Dynamic, true)),
            Some((TK::Reduce, true)),
            Some((TK::Prefer, true)),
            Some((TK::Finish, true)),
            Some((TK::Right, true)),
            Some((TK::Shift, true)),
            Some((TK::Left, true)),
            Some((TK::Name, false)),
            Some((TK::IntConst, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::ZeroOrMoreGreedy, true)),
            Some((TK::OneOrMoreGreedy, true)),
            Some((TK::OptionalGreedy, true)),
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::ZeroOrMore, true)),
            Some((TK::OneOrMore, true)),
            Some((TK::Optional, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
        ],
        [
            Some((TK::ZeroOrMoreGreedy, true)),
            Some((TK::OneOrMoreGreedy, true)),
            Some((TK::OptionalGreedy, true)),
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::ZeroOrMore, true)),
            Some((TK::OneOrMore, true)),
            Some((TK::Optional, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Name, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OBracket, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::NoFinish, true)),
            Some((TK::Dynamic, true)),
            Some((TK::Reduce, true)),
            Some((TK::Prefer, true)),
            Some((TK::Finish, true)),
            Some((TK::Right, true)),
            Some((TK::Shift, true)),
            Some((TK::Left, true)),
            Some((TK::Name, false)),
            Some((TK::IntConst, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CSBracket, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CSBracket, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CSBracket, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::Choice, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CBrace, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Name, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::SemiColon, true)),
            Some((TK::OBrace, true)),
            Some((TK::OBracket, true)),
            Some((TK::CBracket, true)),
            Some((TK::Choice, true)),
            Some((TK::Name, false)),
            Some((TK::StrConst, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Terminals, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Name, false)),
            Some((TK::Annotation, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::Comma, true)),
            Some((TK::CSBracket, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::OComment, true)),
            Some((TK::WS, false)),
            Some((TK::CommentLine, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OComment, true)),
            Some((TK::CComment, true)),
            Some((TK::WS, false)),
            Some((TK::CommentLine, false)),
            Some((TK::NotComment, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::OComment, true)),
            Some((TK::WS, false)),
            Some((TK::CommentLine, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::OComment, true)),
            Some((TK::CComment, true)),
            Some((TK::WS, false)),
            Some((TK::CommentLine, false)),
            Some((TK::NotComment, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::OComment, true)),
            Some((TK::WS, false)),
            Some((TK::CommentLine, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::OComment, true)),
            Some((TK::WS, false)),
            Some((TK::CommentLine, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::OComment, true)),
            Some((TK::WS, false)),
            Some((TK::CommentLine, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OComment, true)),
            Some((TK::CComment, true)),
            Some((TK::WS, false)),
            Some((TK::CommentLine, false)),
            Some((TK::NotComment, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OComment, true)),
            Some((TK::CComment, true)),
            Some((TK::WS, false)),
            Some((TK::CommentLine, false)),
            Some((TK::NotComment, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OComment, true)),
            Some((TK::CComment, true)),
            Some((TK::WS, false)),
            Some((TK::CommentLine, false)),
            Some((TK::NotComment, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::CComment, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OComment, true)),
            Some((TK::CComment, true)),
            Some((TK::WS, false)),
            Some((TK::CommentLine, false)),
            Some((TK::NotComment, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::CComment, true)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OComment, true)),
            Some((TK::CComment, true)),
            Some((TK::WS, false)),
            Some((TK::CommentLine, false)),
            Some((TK::NotComment, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::OComment, true)),
            Some((TK::WS, false)),
            Some((TK::CommentLine, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::OComment, true)),
            Some((TK::CComment, true)),
            Some((TK::WS, false)),
            Some((TK::CommentLine, false)),
            Some((TK::NotComment, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OComment, true)),
            Some((TK::CComment, true)),
            Some((TK::WS, false)),
            Some((TK::CommentLine, false)),
            Some((TK::NotComment, false)),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ],
    ],
};
impl ParserDefinition<State, ProdKind, TokenKind, NonTermKind>
for RustemoParserDefinition {
    fn actions(&self, state: State, token: TokenKind) -> Vec<Action<State, ProdKind>> {
        PARSER_DEFINITION.actions[state as usize](token)
    }
    fn goto(&self, state: State, nonterm: NonTermKind) -> State {
        PARSER_DEFINITION.gotos[state as usize](nonterm)
    }
    fn expected_token_kinds(&self, state: State) -> Vec<(TokenKind, bool)> {
        PARSER_DEFINITION.token_kinds[state as usize].iter().map_while(|t| *t).collect()
    }
    fn longest_match() -> bool {
        true
    }
    fn grammar_order() -> bool {
        true
    }
}
pub(crate) type Context<'i, I> = LRContext<'i, I, State, TokenKind>;
pub struct RustemoParser<
    'i,
    I: InputT + ?Sized,
    L: Lexer<'i, Context<'i, I>, State, TokenKind, Input = I>,
    B,
>(
    LRParser<
        'i,
        Context<'i, I>,
        State,
        ProdKind,
        TokenKind,
        NonTermKind,
        RustemoParserDefinition,
        L,
        B,
        I,
    >,
);
#[allow(dead_code)]
impl<
    'i,
> RustemoParser<
    'i,
    Input,
    StringLexer<Context<'i, Input>, State, TokenKind, TokenRecognizer, TERMINAL_COUNT>,
    DefaultBuilder,
> {
    pub fn new() -> Self {
        Self(
            LRParser::new(
                &PARSER_DEFINITION,
                State::default(),
                false,
                true,
                StringLexer::new(false, &RECOGNIZERS),
                DefaultBuilder::new(),
            ),
        )
    }
}
#[allow(dead_code)]
impl<'i, I, L, B> Parser<'i, I, Context<'i, I>, State, TokenKind>
for RustemoParser<'i, I, L, B>
where
    I: InputT + ?Sized + Debug,
    L: Lexer<'i, Context<'i, I>, State, TokenKind, Input = I>,
    B: LRBuilder<'i, I, Context<'i, I>, State, ProdKind, TokenKind>,
{
    type Output = B::Output;
    fn parse(&self, input: &'i I) -> Result<Self::Output> {
        self.0.parse(input)
    }
    fn parse_with_context(
        &self,
        context: &mut Context<'i, I>,
        input: &'i I,
    ) -> Result<Self::Output> {
        self.0.parse_with_context(context, input)
    }
    fn parse_file<'a, F: AsRef<std::path::Path>>(
        &'a mut self,
        file: F,
    ) -> Result<Self::Output>
    where
        'a: 'i,
    {
        self.0.parse_file(file)
    }
}
#[allow(dead_code)]
#[derive(Debug)]
pub enum Recognizer {
    Stop,
    StrMatch(&'static str),
    RegexMatch(Lazy<Regex>),
}
#[allow(dead_code)]
#[derive(Debug)]
pub struct TokenRecognizer(TokenKind, Recognizer);
impl<'i> TokenRecognizerT<'i> for TokenRecognizer {
    fn recognize(&self, input: &'i str) -> Option<&'i str> {
        match &self {
            #[allow(unused_variables)]
            TokenRecognizer(token_kind, Recognizer::StrMatch(s)) => {
                logn!("{} {:?} -- ", "    Recognizing".green(), token_kind);
                if input.starts_with(s) {
                    log!("{}", "recognized".bold().green());
                    Some(s)
                } else {
                    log!("{}", "not recognized".red());
                    None
                }
            }
            #[allow(unused_variables)]
            TokenRecognizer(token_kind, Recognizer::RegexMatch(r)) => {
                logn!("{} {:?} -- ", "    Recognizing".green(), token_kind);
                let match_str = r.find(input);
                match match_str {
                    Some(x) => {
                        let x_str = x.as_str();
                        log!("{} '{}'", "recognized".bold().green(), x_str);
                        Some(x_str)
                    }
                    _ => {
                        log!("{}", "not recognized".red());
                        None
                    }
                }
            }
            TokenRecognizer(_, Recognizer::Stop) => {
                logn!("{} STOP -- ", "    Recognizing".green());
                if input.is_empty() {
                    log!("{}", "recognized".bold().green());
                    Some("")
                } else {
                    log!("{}", "not recognized".red());
                    None
                }
            }
        }
    }
}
pub(crate) static RECOGNIZERS: [TokenRecognizer; TERMINAL_COUNT] = [
    TokenRecognizer(TokenKind::STOP, Recognizer::Stop),
    TokenRecognizer(TokenKind::Terminals, Recognizer::StrMatch("terminals")),
    TokenRecognizer(TokenKind::Import, Recognizer::StrMatch("import")),
    TokenRecognizer(TokenKind::As, Recognizer::StrMatch("as")),
    TokenRecognizer(TokenKind::Colon, Recognizer::StrMatch(":")),
    TokenRecognizer(TokenKind::SemiColon, Recognizer::StrMatch(";")),
    TokenRecognizer(TokenKind::Comma, Recognizer::StrMatch(",")),
    TokenRecognizer(TokenKind::OBrace, Recognizer::StrMatch("{")),
    TokenRecognizer(TokenKind::CBrace, Recognizer::StrMatch("}")),
    TokenRecognizer(TokenKind::OBracket, Recognizer::StrMatch("(")),
    TokenRecognizer(TokenKind::CBracket, Recognizer::StrMatch(")")),
    TokenRecognizer(TokenKind::OSBracket, Recognizer::StrMatch("[")),
    TokenRecognizer(TokenKind::CSBracket, Recognizer::StrMatch("]")),
    TokenRecognizer(TokenKind::Choice, Recognizer::StrMatch("|")),
    TokenRecognizer(TokenKind::ZeroOrMore, Recognizer::StrMatch("*")),
    TokenRecognizer(TokenKind::ZeroOrMoreGreedy, Recognizer::StrMatch("*!")),
    TokenRecognizer(TokenKind::OneOrMore, Recognizer::StrMatch("+")),
    TokenRecognizer(TokenKind::OneOrMoreGreedy, Recognizer::StrMatch("+!")),
    TokenRecognizer(TokenKind::Optional, Recognizer::StrMatch("?")),
    TokenRecognizer(TokenKind::OptionalGreedy, Recognizer::StrMatch("?!")),
    TokenRecognizer(TokenKind::Equals, Recognizer::StrMatch("=")),
    TokenRecognizer(TokenKind::QEquals, Recognizer::StrMatch("?=")),
    TokenRecognizer(TokenKind::Left, Recognizer::StrMatch("left")),
    TokenRecognizer(TokenKind::Right, Recognizer::StrMatch("right")),
    TokenRecognizer(TokenKind::Reduce, Recognizer::StrMatch("reduce")),
    TokenRecognizer(TokenKind::Shift, Recognizer::StrMatch("shift")),
    TokenRecognizer(TokenKind::Dynamic, Recognizer::StrMatch("dynamic")),
    TokenRecognizer(TokenKind::NOPS, Recognizer::StrMatch("nops")),
    TokenRecognizer(TokenKind::NOPSE, Recognizer::StrMatch("nopse")),
    TokenRecognizer(TokenKind::Prefer, Recognizer::StrMatch("prefer")),
    TokenRecognizer(TokenKind::Finish, Recognizer::StrMatch("finish")),
    TokenRecognizer(TokenKind::NoFinish, Recognizer::StrMatch("nofinish")),
    TokenRecognizer(TokenKind::OComment, Recognizer::StrMatch("/*")),
    TokenRecognizer(TokenKind::CComment, Recognizer::StrMatch("*/")),
    TokenRecognizer(
        TokenKind::Name,
        Recognizer::RegexMatch(
            Lazy::new(|| {
                Regex::new(concat!("^", "[a-zA-Z_][a-zA-Z0-9_\\.]*")).unwrap()
            }),
        ),
    ),
    TokenRecognizer(
        TokenKind::RegexTerm,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "/(\\\\.|[^/\\\\])*/")).unwrap() }),
        ),
    ),
    TokenRecognizer(
        TokenKind::IntConst,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "\\d+")).unwrap() }),
        ),
    ),
    TokenRecognizer(
        TokenKind::FloatConst,
        Recognizer::RegexMatch(
            Lazy::new(|| {
                Regex::new(concat!("^", "[+-]?[0-9]+[.][0-9]*([e][+-]?[0-9]+)?"))
                    .unwrap()
            }),
        ),
    ),
    TokenRecognizer(
        TokenKind::BoolConst,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "true|false")).unwrap() }),
        ),
    ),
    TokenRecognizer(
        TokenKind::StrConst,
        Recognizer::RegexMatch(
            Lazy::new(|| {
                Regex::new(
                        concat!(
                            "^",
                            "(?s)(^'[^'\\\\]*(?:\\\\.[^'\\\\]*)*')|(^\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")"
                        ),
                    )
                    .unwrap()
            }),
        ),
    ),
    TokenRecognizer(
        TokenKind::Annotation,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "@[a-zA-Z0-9_]+")).unwrap() }),
        ),
    ),
    TokenRecognizer(
        TokenKind::WS,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "\\s+")).unwrap() }),
        ),
    ),
    TokenRecognizer(
        TokenKind::CommentLine,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "//.*")).unwrap() }),
        ),
    ),
    TokenRecognizer(
        TokenKind::NotComment,
        Recognizer::RegexMatch(
            Lazy::new(|| {
                Regex::new(concat!("^", "((\\*[^/])|[^\\s*/]|/[^\\*])+")).unwrap()
            }),
        ),
    ),
];
pub struct DefaultBuilder {
    res_stack: Vec<Symbol>,
}
impl DefaultBuilder {
    #[allow(dead_code)]
    pub fn new() -> Self {
        Self { res_stack: vec![] }
    }
}
impl Builder for DefaultBuilder {
    type Output = rustemo_actions::File;
    fn get_result(&mut self) -> Self::Output {
        match self.res_stack.pop().unwrap() {
            Symbol::NonTerminal(NonTerminal::File(r)) => r,
            _ => panic!("Invalid result on the parse stack!"),
        }
    }
}
impl<'i> LRBuilder<'i, Input, Context<'i, Input>, State, ProdKind, TokenKind>
for DefaultBuilder {
    #![allow(unused_variables)]
    fn shift_action(
        &mut self,
        context: &Context<'i, Input>,
        token: Token<'i, Input, TokenKind>,
    ) {
        let val = match token.kind {
            TokenKind::STOP => panic!("Cannot shift STOP token!"),
            TokenKind::Terminals => Terminal::Terminals,
            TokenKind::Import => Terminal::Import,
            TokenKind::As => Terminal::As,
            TokenKind::Colon => Terminal::Colon,
            TokenKind::SemiColon => Terminal::SemiColon,
            TokenKind::Comma => Terminal::Comma,
            TokenKind::OBrace => Terminal::OBrace,
            TokenKind::CBrace => Terminal::CBrace,
            TokenKind::OBracket => Terminal::OBracket,
            TokenKind::CBracket => Terminal::CBracket,
            TokenKind::OSBracket => Terminal::OSBracket,
            TokenKind::CSBracket => Terminal::CSBracket,
            TokenKind::Choice => Terminal::Choice,
            TokenKind::ZeroOrMore => Terminal::ZeroOrMore,
            TokenKind::ZeroOrMoreGreedy => Terminal::ZeroOrMoreGreedy,
            TokenKind::OneOrMore => Terminal::OneOrMore,
            TokenKind::OneOrMoreGreedy => Terminal::OneOrMoreGreedy,
            TokenKind::Optional => Terminal::Optional,
            TokenKind::OptionalGreedy => Terminal::OptionalGreedy,
            TokenKind::Equals => Terminal::Equals,
            TokenKind::QEquals => Terminal::QEquals,
            TokenKind::Left => Terminal::Left,
            TokenKind::Right => Terminal::Right,
            TokenKind::Reduce => Terminal::Reduce,
            TokenKind::Shift => Terminal::Shift,
            TokenKind::Dynamic => Terminal::Dynamic,
            TokenKind::NOPS => Terminal::NOPS,
            TokenKind::NOPSE => Terminal::NOPSE,
            TokenKind::Prefer => Terminal::Prefer,
            TokenKind::Finish => Terminal::Finish,
            TokenKind::NoFinish => Terminal::NoFinish,
            TokenKind::Name => Terminal::Name(rustemo_actions::name(context, token)),
            TokenKind::RegexTerm => {
                Terminal::RegexTerm(rustemo_actions::regex_term(context, token))
            }
            TokenKind::IntConst => {
                Terminal::IntConst(rustemo_actions::int_const(context, token))
            }
            TokenKind::FloatConst => {
                Terminal::FloatConst(rustemo_actions::float_const(context, token))
            }
            TokenKind::BoolConst => {
                Terminal::BoolConst(rustemo_actions::bool_const(context, token))
            }
            TokenKind::StrConst => {
                Terminal::StrConst(rustemo_actions::str_const(context, token))
            }
            TokenKind::Annotation => {
                Terminal::Annotation(rustemo_actions::annotation(context, token))
            }
            _ => panic!("Shift of unreachable terminal!"),
        };
        self.res_stack.push(Symbol::Terminal(val));
    }
    fn reduce_action(
        &mut self,
        context: &Context<'i, Input>,
        prod: ProdKind,
        prod_len: usize,
    ) {
        let prod = match prod {
            ProdKind::FileP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::GrammarRule1(p0)) => {
                        NonTerminal::File(
                            rustemo_actions::file_grammar_rule1(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::GrammarRule1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::GrammarRule1(p0)),
                        Symbol::NonTerminal(NonTerminal::GrammarRule(p1)),
                    ) => {
                        NonTerminal::GrammarRule1(
                            rustemo_actions::grammar_rule1_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::GrammarRule1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::GrammarRule(p0)) => {
                        NonTerminal::GrammarRule1(
                            rustemo_actions::grammar_rule1_grammar_rule(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::FileP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::ImportStm1(p0)),
                        Symbol::NonTerminal(NonTerminal::GrammarRule1(p1)),
                    ) => NonTerminal::File(rustemo_actions::file_c2(context, p0, p1)),
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ImportStm1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::ImportStm1(p0)),
                        Symbol::NonTerminal(NonTerminal::ImportStm(p1)),
                    ) => {
                        NonTerminal::ImportStm1(
                            rustemo_actions::import_stm1_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ImportStm1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::ImportStm(p0)) => {
                        NonTerminal::ImportStm1(
                            rustemo_actions::import_stm1_import_stm(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::FileP3 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::GrammarRule1(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::TerminalRule1(p1)),
                    ) => NonTerminal::File(rustemo_actions::file_c3(context, p0, p1)),
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::TerminalRule1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::TerminalRule1(p0)),
                        Symbol::NonTerminal(NonTerminal::TerminalRule(p1)),
                    ) => {
                        NonTerminal::TerminalRule1(
                            rustemo_actions::terminal_rule1_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::TerminalRule1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::TerminalRule(p0)) => {
                        NonTerminal::TerminalRule1(
                            rustemo_actions::terminal_rule1_terminal_rule(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::FileP4 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 4usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::NonTerminal(NonTerminal::ImportStm1(p0)),
                        Symbol::NonTerminal(NonTerminal::GrammarRule1(p1)),
                        _,
                        Symbol::NonTerminal(NonTerminal::TerminalRule1(p2)),
                    ) => NonTerminal::File(rustemo_actions::file_c4(context, p0, p1, p2)),
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::FileP5 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (_, Symbol::NonTerminal(NonTerminal::TerminalRule1(p0))) => {
                        NonTerminal::File(
                            rustemo_actions::file_terminal_rule1(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ImportStmP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (_, Symbol::Terminal(Terminal::StrConst(p0))) => {
                        NonTerminal::ImportStm(
                            rustemo_actions::import_stm_c1(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ImportStmP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 4usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        Symbol::Terminal(Terminal::StrConst(p0)),
                        _,
                        Symbol::Terminal(Terminal::Name(p1)),
                    ) => {
                        NonTerminal::ImportStm(
                            rustemo_actions::import_stm_c2(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::GrammarRuleP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 5usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::NonTerminal(NonTerminal::AnnotationOpt(p0)),
                        Symbol::Terminal(Terminal::Name(p1)),
                        _,
                        Symbol::NonTerminal(NonTerminal::GrammarRuleRHS(p2)),
                        _,
                    ) => {
                        NonTerminal::GrammarRule(
                            rustemo_actions::grammar_rule_c1(context, p0, p1, p2),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::AnnotationOptP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::Annotation(p0)) => {
                        NonTerminal::AnnotationOpt(
                            rustemo_actions::annotation_opt_annotation(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::AnnotationOptP2 => {
                NonTerminal::AnnotationOpt(
                    rustemo_actions::annotation_opt_empty(context),
                )
            }
            ProdKind::GrammarRuleP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 8usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::NonTerminal(NonTerminal::AnnotationOpt(p0)),
                        Symbol::Terminal(Terminal::Name(p1)),
                        _,
                        Symbol::NonTerminal(NonTerminal::ProdMetaDatas(p2)),
                        _,
                        _,
                        Symbol::NonTerminal(NonTerminal::GrammarRuleRHS(p3)),
                        _,
                    ) => {
                        NonTerminal::GrammarRule(
                            rustemo_actions::grammar_rule_c2(context, p0, p1, p2, p3),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::GrammarRuleRHSP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::GrammarRuleRHS(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Production(p1)),
                    ) => {
                        NonTerminal::GrammarRuleRHS(
                            rustemo_actions::grammar_rule_rhs_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::GrammarRuleRHSP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Production(p0)) => {
                        NonTerminal::GrammarRuleRHS(
                            rustemo_actions::grammar_rule_rhs_production(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ProductionP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Assignment1(p0)) => {
                        NonTerminal::Production(
                            rustemo_actions::production_assignment1(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Assignment1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Assignment1(p0)),
                        Symbol::NonTerminal(NonTerminal::Assignment(p1)),
                    ) => {
                        NonTerminal::Assignment1(
                            rustemo_actions::assignment1_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Assignment1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Assignment(p0)) => {
                        NonTerminal::Assignment1(
                            rustemo_actions::assignment1_assignment(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ProductionP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 4usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::NonTerminal(NonTerminal::Assignment1(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::ProdMetaDatas(p1)),
                        _,
                    ) => {
                        NonTerminal::Production(
                            rustemo_actions::production_c2(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::TerminalRuleP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 5usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::NonTerminal(NonTerminal::AnnotationOpt(p0)),
                        Symbol::Terminal(Terminal::Name(p1)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Recognizer(p2)),
                        _,
                    ) => {
                        NonTerminal::TerminalRule(
                            rustemo_actions::terminal_rule_c1(context, p0, p1, p2),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::TerminalRuleP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 4usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::NonTerminal(NonTerminal::AnnotationOpt(p0)),
                        Symbol::Terminal(Terminal::Name(p1)),
                        _,
                        _,
                    ) => {
                        NonTerminal::TerminalRule(
                            rustemo_actions::terminal_rule_c2(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::TerminalRuleP3 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 8usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::NonTerminal(NonTerminal::AnnotationOpt(p0)),
                        Symbol::Terminal(Terminal::Name(p1)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Recognizer(p2)),
                        _,
                        Symbol::NonTerminal(NonTerminal::TermMetaDatas(p3)),
                        _,
                        _,
                    ) => {
                        NonTerminal::TerminalRule(
                            rustemo_actions::terminal_rule_c3(context, p0, p1, p2, p3),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::TerminalRuleP4 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 7usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::NonTerminal(NonTerminal::AnnotationOpt(p0)),
                        Symbol::Terminal(Terminal::Name(p1)),
                        _,
                        _,
                        Symbol::NonTerminal(NonTerminal::TermMetaDatas(p2)),
                        _,
                        _,
                    ) => {
                        NonTerminal::TerminalRule(
                            rustemo_actions::terminal_rule_c4(context, p0, p1, p2),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ProdMetaDataLeft => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::ProdMetaData(rustemo_actions::prod_meta_data_left(context))
            }
            ProdKind::ProdMetaDataReduce => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::ProdMetaData(
                    rustemo_actions::prod_meta_data_reduce(context),
                )
            }
            ProdKind::ProdMetaDataRight => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::ProdMetaData(rustemo_actions::prod_meta_data_right(context))
            }
            ProdKind::ProdMetaDataShift => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::ProdMetaData(rustemo_actions::prod_meta_data_shift(context))
            }
            ProdKind::ProdMetaDataDynamic => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::ProdMetaData(
                    rustemo_actions::prod_meta_data_dynamic(context),
                )
            }
            ProdKind::ProdMetaDataNOPS => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::ProdMetaData(rustemo_actions::prod_meta_data_nops(context))
            }
            ProdKind::ProdMetaDataNOPSE => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::ProdMetaData(rustemo_actions::prod_meta_data_nopse(context))
            }
            ProdKind::ProdMetaDataPriority => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::IntConst(p0)) => {
                        NonTerminal::ProdMetaData(
                            rustemo_actions::prod_meta_data_priority(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ProdMetaDataP9 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::UserMetaData(p0)) => {
                        NonTerminal::ProdMetaData(
                            rustemo_actions::prod_meta_data_user_meta_data(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ProdMetaDataP10 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::ProdKind(p0)) => {
                        NonTerminal::ProdMetaData(
                            rustemo_actions::prod_meta_data_prod_kind(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ProdMetaDatasP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::ProdMetaDatas(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::ProdMetaData(p1)),
                    ) => {
                        NonTerminal::ProdMetaDatas(
                            rustemo_actions::prod_meta_datas_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ProdMetaDatasP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::ProdMetaData(p0)) => {
                        NonTerminal::ProdMetaDatas(
                            rustemo_actions::prod_meta_datas_c2(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::TermMetaDataPrefer => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::TermMetaData(
                    rustemo_actions::term_meta_data_prefer(context),
                )
            }
            ProdKind::TermMetaDataFinish => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::TermMetaData(
                    rustemo_actions::term_meta_data_finish(context),
                )
            }
            ProdKind::TermMetaDataNoFinish => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::TermMetaData(
                    rustemo_actions::term_meta_data_no_finish(context),
                )
            }
            ProdKind::TermMetaDataLeft => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::TermMetaData(rustemo_actions::term_meta_data_left(context))
            }
            ProdKind::TermMetaDataReduce => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::TermMetaData(
                    rustemo_actions::term_meta_data_reduce(context),
                )
            }
            ProdKind::TermMetaDataRight => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::TermMetaData(rustemo_actions::term_meta_data_right(context))
            }
            ProdKind::TermMetaDataShift => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::TermMetaData(rustemo_actions::term_meta_data_shift(context))
            }
            ProdKind::TermMetaDataDynamic => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::TermMetaData(
                    rustemo_actions::term_meta_data_dynamic(context),
                )
            }
            ProdKind::TermMetaDataPriority => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::IntConst(p0)) => {
                        NonTerminal::TermMetaData(
                            rustemo_actions::term_meta_data_priority(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::TermMetaDataP10 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::UserMetaData(p0)) => {
                        NonTerminal::TermMetaData(
                            rustemo_actions::term_meta_data_user_meta_data(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::TermMetaDatasP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::TermMetaDatas(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::TermMetaData(p1)),
                    ) => {
                        NonTerminal::TermMetaDatas(
                            rustemo_actions::term_meta_datas_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::TermMetaDatasP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::TermMetaData(p0)) => {
                        NonTerminal::TermMetaDatas(
                            rustemo_actions::term_meta_datas_c2(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::UserMetaDataP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::Terminal(Terminal::Name(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::ConstVal(p1)),
                    ) => {
                        NonTerminal::UserMetaData(
                            rustemo_actions::user_meta_data_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ProdKindP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::Name(p0)) => {
                        NonTerminal::ProdKind(
                            rustemo_actions::prod_kind_name(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ConstValP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::IntConst(p0)) => {
                        NonTerminal::ConstVal(
                            rustemo_actions::const_val_int_const(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ConstValP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::FloatConst(p0)) => {
                        NonTerminal::ConstVal(
                            rustemo_actions::const_val_float_const(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ConstValP3 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::BoolConst(p0)) => {
                        NonTerminal::ConstVal(
                            rustemo_actions::const_val_bool_const(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ConstValP4 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::StrConst(p0)) => {
                        NonTerminal::ConstVal(
                            rustemo_actions::const_val_str_const(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::AssignmentP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::PlainAssignment(p0)) => {
                        NonTerminal::Assignment(
                            rustemo_actions::assignment_plain_assignment(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::AssignmentP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::BoolAssignment(p0)) => {
                        NonTerminal::Assignment(
                            rustemo_actions::assignment_bool_assignment(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::AssignmentP3 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::GrammarSymbolRef(p0)) => {
                        NonTerminal::Assignment(
                            rustemo_actions::assignment_grammar_symbol_ref(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::PlainAssignmentP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::Terminal(Terminal::Name(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::GrammarSymbolRef(p1)),
                    ) => {
                        NonTerminal::PlainAssignment(
                            rustemo_actions::plain_assignment_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::BoolAssignmentP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::Terminal(Terminal::Name(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::GrammarSymbolRef(p1)),
                    ) => {
                        NonTerminal::BoolAssignment(
                            rustemo_actions::bool_assignment_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ProductionGroupP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (_, Symbol::NonTerminal(NonTerminal::GrammarRuleRHS(p0)), _) => {
                        NonTerminal::ProductionGroup(
                            rustemo_actions::production_group_c1(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::GrammarSymbolRefP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::GrammarSymbol(p0)),
                        Symbol::NonTerminal(NonTerminal::RepetitionOperatorOpt(p1)),
                    ) => {
                        NonTerminal::GrammarSymbolRef(
                            rustemo_actions::grammar_symbol_ref_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::RepetitionOperatorOptP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::RepetitionOperator(p0)) => {
                        NonTerminal::RepetitionOperatorOpt(
                            rustemo_actions::repetition_operator_opt_repetition_operator(
                                context,
                                p0,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::RepetitionOperatorOptP2 => {
                NonTerminal::RepetitionOperatorOpt(
                    rustemo_actions::repetition_operator_opt_empty(context),
                )
            }
            ProdKind::GrammarSymbolRefP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::ProductionGroup(p0)),
                        Symbol::NonTerminal(NonTerminal::RepetitionOperatorOpt(p1)),
                    ) => {
                        NonTerminal::GrammarSymbolRef(
                            rustemo_actions::grammar_symbol_ref_c2(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::RepetitionOperatorP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::RepetitionOperatorOp(p0)),
                        Symbol::NonTerminal(NonTerminal::RepetitionModifiersOpt(p1)),
                    ) => {
                        NonTerminal::RepetitionOperator(
                            rustemo_actions::repetition_operator_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::RepetitionModifiersOptP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::RepetitionModifiers(p0)) => {
                        NonTerminal::RepetitionModifiersOpt(
                            rustemo_actions::repetition_modifiers_opt_repetition_modifiers(
                                context,
                                p0,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::RepetitionModifiersOptP2 => {
                NonTerminal::RepetitionModifiersOpt(
                    rustemo_actions::repetition_modifiers_opt_empty(context),
                )
            }
            ProdKind::RepetitionOperatorOpZeroOrMore => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::RepetitionOperatorOp(
                    rustemo_actions::repetition_operator_op_zero_or_more(context),
                )
            }
            ProdKind::RepetitionOperatorOpZeroOrMoreGreedy => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::RepetitionOperatorOp(
                    rustemo_actions::repetition_operator_op_zero_or_more_greedy(context),
                )
            }
            ProdKind::RepetitionOperatorOpOneOrMore => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::RepetitionOperatorOp(
                    rustemo_actions::repetition_operator_op_one_or_more(context),
                )
            }
            ProdKind::RepetitionOperatorOpOneOrMoreGreedy => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::RepetitionOperatorOp(
                    rustemo_actions::repetition_operator_op_one_or_more_greedy(context),
                )
            }
            ProdKind::RepetitionOperatorOpOptional => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::RepetitionOperatorOp(
                    rustemo_actions::repetition_operator_op_optional(context),
                )
            }
            ProdKind::RepetitionOperatorOpOptionalGreedy => {
                let _ = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                NonTerminal::RepetitionOperatorOp(
                    rustemo_actions::repetition_operator_op_optional_greedy(context),
                )
            }
            ProdKind::RepetitionModifiersP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (_, Symbol::NonTerminal(NonTerminal::RepetitionModifier1(p0)), _) => {
                        NonTerminal::RepetitionModifiers(
                            rustemo_actions::repetition_modifiers_repetition_modifier1(
                                context,
                                p0,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::RepetitionModifier1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::RepetitionModifier1(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::RepetitionModifier(p1)),
                    ) => {
                        NonTerminal::RepetitionModifier1(
                            rustemo_actions::repetition_modifier1_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::RepetitionModifier1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::RepetitionModifier(p0)) => {
                        NonTerminal::RepetitionModifier1(
                            rustemo_actions::repetition_modifier1_repetition_modifier(
                                context,
                                p0,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::RepetitionModifierP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::Name(p0)) => {
                        NonTerminal::RepetitionModifier(
                            rustemo_actions::repetition_modifier_name(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::GrammarSymbolP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::Name(p0)) => {
                        NonTerminal::GrammarSymbol(
                            rustemo_actions::grammar_symbol_name(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::GrammarSymbolP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::StrConst(p0)) => {
                        NonTerminal::GrammarSymbol(
                            rustemo_actions::grammar_symbol_str_const(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::RecognizerP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::StrConst(p0)) => {
                        NonTerminal::Recognizer(
                            rustemo_actions::recognizer_str_const(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::RecognizerP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::RegexTerm(p0)) => {
                        NonTerminal::Recognizer(
                            rustemo_actions::recognizer_regex_term(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            _ => panic!("Reduce of unreachable nonterminal!"),
        };
        self.res_stack.push(Symbol::NonTerminal(prod));
    }
}
